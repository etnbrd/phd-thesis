Automatically generated by Mendeley Desktop 1.12.3-dev1
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Rinard1996,
author = {Rinard, MC and Diniz, PC},
journal = {ACM SIGPLAN Notices},
title = {{Commutativity analysis: A new analysis framework for parallelizing compilers}},
url = {http://dl.acm.org/citation.cfm?id=231390},
year = {1996}
}
@inproceedings{Jr1990,
abstract = {We need a programming model that com- bines the advantages of the synchronous and asyn- chronous parallel styles. Synchronous programs are de- terminate (thus easier to reason about) and avoid syn- chronization overheads. Asynchronous programs are more flexible and handle conditionals more efficiently. Here we propose a programming model with the ben- efits of both styles. We allow asynchronous threads of control but restrict shared-memory accesses and other side effects so as to prevent the behavior of the program from depending on any accidents of execution order that can arise from the indeterminacy of the asynchronous process model. These restrictions may be enforced either dynam- ically (at run time) or statically (at compile time). In this paper we concentrate on dynamic enforcement, and exhibit an implementation of a parallel dialect of Scheme based on these ideas. A single successful exe- cution of a parallel program in this model constitutes a proof that the program is free of race conditions (for that particular set of input data). We also speculate on a design for a programming lan- guage using static enforcement. The notion of distinct- ness is important to proofs of noninterference. An ap- propriately designed programming language must sup port such concepts as “all the elements of this array are distinct,” perhaps through its type system. This parallel programming model does not support all styles of parallel programming, but we argue that it can support a large class of interesting algorithms with considerably greater efficiency (in some cases) than a strict SIMD approach and considerably greater safety (in all cases) than a full-blown MIMD approach.},
author = {Guy, L and Steele, Jr},
booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
doi = {10.1145/96709.96731},
isbn = {0-89791-343-4},
issn = {07308566},
pages = {218--231},
title = {{Making asynchronous parallelism safe for the world}},
url = {http://dl.acm.org/citation.cfm?id=96731},
year = {1990}
}
@inproceedings{Clements2013a,
address = {New York, New York, USA},
author = {Clements, Austin T. and Kaashoek, M. Frans and Zeldovich, Nickolai and Morris, Robert T. and Kohler, Eddie},
booktitle = {Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles - SOSP '13},
doi = {10.1145/2517349.2522712},
file = {:home/etn/Documents/PhD/Biblio/Clements et al. - 2013 - The scalable commutativity rule.pdf:pdf},
isbn = {9781450323888},
month = nov,
pages = {1--17},
publisher = {ACM Press},
title = {{The scalable commutativity rule}},
url = {http://dl.acm.org/citation.cfm?id=2517349.2522712},
year = {2013}
}
