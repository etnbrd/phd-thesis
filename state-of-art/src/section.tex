\section{State of the Art}

keywords :

\begin{itemize}
	\item Synchronous vs Asynchronous
	\item Blocking vs Non-Blocking
	\item Pull / Push
	\item Poll / Interupt

	\item Promises
	\item Futures
	\item Delay
	\item Callback
	\item Channels
	
	\item Reactive programming

	\item Interuptions
	\item Function Pointer
\end{itemize}


The computing world is based on this duality : Synchronous / Asynchronous.

Synchronous computing allow easy understanding of the computation structure, possible estimation of computation performances a priori, at the detriment of overall performance.
While Asynchronous computing globally improves performances, but reduce the possiblity to understand the structure, or to measure a priori these performances.

We can make a comparison between Operating Systems and Javascript.
See all the documents I write already on why a browser/social network is an Operating System.
The compparison goes further : Operating Systems made a swtich from synchronous computation to asynchronous computating for performance issues using interuptions.
UI system made the exact same shift for other reasons, for example with X11 with pointer to functions to call to render a window.
Javascript made the same shift with callback.


Many tried to combine the advantages of both, with systems to transform one into another : to provide easy understanding of computation structure, while overall good performances.


