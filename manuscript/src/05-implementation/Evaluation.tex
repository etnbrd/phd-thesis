\section{Evaluation} \label{chapter4:evaluation}

The compiler previously presented is evaluated against the criteria presented in chapter \ref{chapter3}.
The criteria are Productivity, Efficiency and Adoption.

\subsection{Trading Productivity for Efficiency}

% \subsubsection{Productivity}

The compiler intends to disrupt as less as possible the way developer build web applications.
The goal is to avoid degrading the productivity, hence the adoption, of the proposed platform.
% The source language, Javascript, is left intact, except for the forbidden statements \texttt{with} and \texttt{eval}.
% These statements are already forbidden by some good practice guides \cite{Crockford2008}.
Therefore, the productivity is potentially the same as the original event-driven platform.

However, in the current state, the compiler implementation is unable to operate the transformation without an external help.
The static analysis is unable to correctly detect the aliasing of the memory in Javascript.
This limitation avoid to improve the current trade-off of productivity for efficiency, as illustrated in table \ref{tab:proposition-productivity}.

\TablePropositionProductivity{tab:proposition-productivity}

% \subsubsection{Efficiency}

Indeed, to gain efficiency, developers need to commit efforts to indicate the stages of the pipeline, and assure their dependency.
Notably, it avoids the higher-order programming required for good composition.
The manual transformation process yields a distributed application, similarly as the other efficient platforms.
And the chapter \ref{chapter3} showed that such applications achieve very good performance efficiency.
The proposition actually concedes productivity for efficiency, as illustrated in table \ref{tab:proposition-efficiency}.

\TablePropositionEfficiency{tab:proposition-efficiency}

This limitation of the current implementation avoids the platform to proposes a satisfying compromise between productivity and efficiency.
Perspectives to overcome this limitation are addressed later in section \ref{chapter5:evaluation:perspective}.

% It doesn't make any sense to evaluate an application, as the transformation would not reflect the compilation process, but the manual transformation process.

% If the runtime memory analysis is solid enough to detect correctly the aliasing of the memory, then it will be able to help the development team transitioning from productivity to efficiency, which is the response of this thesis to the problematic.

\subsection{Conclusion}

Because the current implementation is not different than the efficient platform, its adoption is not expected to be different.
As presented in the chapter \ref{chapter3}, trading productivity for efficiency drastically reduce adoption.
Both productivity and efficiency are required for the platform to be adopted by new developers as well as large businesses.
Only at this condition, it reinforces the loop between community and industry.

The adoption of this platform is expected to be similar to other efficient platforms, as illustrated in table \ref{tab:proposition-adoption}.

\TablePropositionAdoption{tab:proposition-adoption}

% It was briefly tested during the development of the grumpy application, presented in chapter \ref{chapter4}, section \ref{chapter4:execution-models:examples}.

\separator

Due to the limitation in static analysis of dynamic languages, the implementation presented in this thesis is unable to address the problematic as expected.
Yet, this limitation avoid the equivalence presented in \ref{chapter4} to be fully implemented.
Therefore, this evaluation holds only on the implementation, and not on the equivalence.


\TablePropositionSummary{tab:proposition-summary}

\cit{it is a mistake to attempt high concurrency without help from the compiler}{R. von Behren, J. Condit and E. Brewer \cite{Behren2003}}

R. von Behren \textit{et al.} implies that the language alone cannot achieve high concurrency.
It is necessary to rely on additional tools, such as a compiler to reach the best compromise between productivity and efficiency.
This evaluation concludes that static analysis is unable to reach this compromise for higher-order programming.
Before dropping all higher-order languages for the sake of efficiency, the next paragraph presents the perspectives of this work to further address this problematic.

% In the contribution of this thesis, the two main difficulties, identifying stages and detecting memory dependencies, are due to the dynamic nature of Javascript.
% A perspective to overcome these limitation is to implement the transformation, not as a compiler, but as a runtime.
% Indeed, at runtime, all the dynamic behavior are resolved, and the analysis can be much more precise, and less speculative.

% \subsection{Fluxionnal Runtime} 

% \section{Perspectives}

% Javascript is a highly dynamic languages.


\section{Perspectives} \label{chapter5:evaluation:perspective}

As stated in the previous chapter, static analysis limits the expressiveness.
For example, to isolate fluxions, the current implementation of the compiler restrains the developer to use only \textit{in situ} callbacks, and avoids aliasing.
Though the work of this thesis can be continued by implementing the compiler with dynamic analysis.

\subsection{Just-in-time Compilation}

Most Javascript interpreters compile some parts of the code at run time to improve performances.
During this compilation, the levels of indirections are mostly resolved.
The code is translated directly into lower-level instructions.

As a continuation of this work, the equivalence could be implemented as a run time compiler.
Such a compiler could leverage the resolution of the variables to analyze their scope, and isolate the code accordingly.

\subsubsection{Rupture point detection}

With the compiler implemented directly inside the interpreter, detecting rupture points become trivial.
Indeed, the interpreter provides the asynchronous functions indicating the rupture points.
It can immediately mark a rupture point when encountered at execution, to detect the stages.

Moreover, with the dynamic resolution of variables, the analysis of interdependencies between stages is trivial.
Each stage can be isolated in a fluxion, and deployed accordingly to its dependencies.

% With the dynamic registering of Fluxions to the messaging system, and into tag groups, it is possible to transform a Javascript application continuously during its execution.
% Analysis of the interdependencies become as trivial as for static languages, with the resolution of the indirections by the just-in-time compiler.
% The fluxional compiler waits for these resolutions, and then analyzes the compiled code for rupture points.
% As the asynchronism of a function call is handled by the execution engine, the just-in-time compilation can pin point precisely the asynchronous calls from the synchronous ones. 
% And the continuations for these asynchronous calls are resolved, which makes them similar to inline continuations.

\subsubsection{Closure Serialization}

The static compiler is unable to manipulate closures, as illustrated in section \ref{chapter5:flx:evaluation:isolation}.
Implementing the compiler at the interpreter level also allows to serialize closures to send them between fluxions.
Closures are required to allow higher-order programming.

\subsubsection{Dynamic Grouping}

The isolation of a fluxion can also be done during the execution.
If it depends on an upstream variable, the fluxion is dynamically registered to the group, and can be deployed.

If the new fluxion depends an a local variable, as well as a variable from a group on another node than the local node, the group needs to be deployed back locally.
The fluxion as well as all the fluxions of the group are deployed locally, but the execution needs to wait for the contexts of the group to be available locally.
To gather the contexts, the node responsible for this group send a message to the messaging system managing this group.
The messaging system gather all the contexts of the fluxions, and send them back.
When the contexts are deployed locally to the new node responsible for the this group, the execution of this branch can resume.

A new compromise have to be done between the cost of sending a fluxion and the cost to get it back, and the risk that it gets sent back.
It might be possible to reduce this risk by saving the compilation information from one execution to the other.


TODO
Similarly to a just-in-time compiler, it is required to check that the compiled code correspond to 


\subsection{Evaluation of the perspective}

However, with a dynamic analysis at runtime, this detection should improve.
And it would allow to operate the transformation without the help of the developer.

In this case, because the productivity is left untouched, this platform should be able to leverage the adoption of Javascript without trouble.
Moreover, Worldline could be able to propose a service based on this transformation.
A scalable PaaS, without the need for the developer to write stateless applications, or other current inconvenient.
