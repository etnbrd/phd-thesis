\section{Fluxions} \label{chapter5:flx}

The previous section presented a compiler to identify and extract the underlying pipeline in a Javascript application.
However, the stages doesn't enforce the isolation required for parallel execution.
Moreover, the Dues that constitues the stages of this pipeline 

only parts of the pipeline are identified, 
This section present the second contribution of this thesis.
The equivalence between a memory shared among all the operations and independent memory for each operation in a pipeline.
It tackles the problems arising from the translation of the global memory synchronization into message passing.

This equivalence is implemented as a compiler, improving upon the previous one.
The compiler transforms a Javascript application into a network of independent parts communicating by message streams and executed in parallel.
We named these parts \textit{fluxions}, by contraction between a flux and a function.
% Fluxions are executed in an execution model that assure parallelism and communications.

% We present an early version of this tool as a proof of concept for this compilation approach.
% Section \ref{chapter5:flx:model} describes the execution model that executes fluxions in parallel, and assure their communications.

The identification of the rupture points between fluxions is addressed in section \ref{chapter5:flx:compiler}.
The isolation between the fluxions, after identification, is addressed in section \ref{chapter5:flx:isolation}.
% The compiler, and the equivalence are described in section \ref{chapter5:flx:compiler}.
Section \ref{chapter5:flx:evaluation} presents a real-case test of compilation, and expose the limits of this compiler.

\input{05-implementation/Flx/Compiler}
\input{05-implementation/Flx/Isolation}
\input{05-implementation/Flx/Evaluation}