Automatically generated by Mendeley Desktop 1.16-dev2
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@article{Nilsson2002,
abstract = {Functional Reactive Programming (FRP) extends a host programming language with a notion of time flow. Arrowized FRP (AFRP) is a version of FRP embedded in Haskell based on the arrow combinators. AFRP is a powerful synchronous dataflow programming language with hybrid modeling capabilities, combining advanced synchronous dataflow features with the higher-order lazy functional abstractions of Haskell. In this paper, we describe the AFRP programming style and our Haskell-based implementation. Of particular interest are the AFRP combinators that support dynamic collections and continuation-based switching. We show how these combinators can be used to express systems with an evolving structure that are difficult to model in more traditional dataflow languages.},
author = {Nilsson, Henrik and Courtney, Antony and Peterson, John},
doi = {10.1145/581690.581695},
institution = {ACM},
isbn = {1581136056},
journal = {Proceedings of the 2002 ACM  {\ldots}},
pages = {51--64},
publisher = {ACM},
series = {Haskell '02},
title = {{Functional reactive programming, continued}},
url = {http://dl.acm.org/citation.cfm?id=581695 http://portal.acm.org/citation.cfm?doid=581690.581695},
year = {2002}
}
@misc{Pembeci2003,
abstract = {In previous work we presented functional reactive programming (FRP), a general framework for designing hybrid systems and developing domain-specific languages for related domains. FRP's synchronous dataflow features, like event driven switching, supported by higher-order lazy functional abstractions of Haskell allows rapid development of modular and reusable specifications. In this paper, we look at more closely to the relation of arrowized FRP (AFRP), the FRP implementation, and formal specification of hybrid systems. We show how a formally specified hybrid system can be expressed in FRP and present a constructive proof showing that, for a subset of AFRP programs, there is a corresponding formal hybrid system specification.},
author = {Pembeci, I and Hager, G},
booktitle = {2003 IEEE International Conference on Robotics and Automation Cat No03CH37422},
doi = {10.1109/ROBOT.2003.1241680},
isbn = {0780377362},
issn = {10504729},
pages = {727--734},
publisher = {Ieee},
title = {{Functional reactive programming as a hybrid system framework}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1241680},
volume = {1},
year = {2003}
}
@article{Sculthorpe2011,
author = {Sculthorpe, N},
title = {{Towards safe and efficient functional reactive programming}},
url = {http://etheses.nottingham.ac.uk/1981/},
year = {2011}
}
@article{Peterson2000,
author = {Peterson, J and Trifonov, V and Serjantov, A},
journal = {Practical Aspects of Declarative  {\ldots}},
title = {{Parallel functional reactive programming}},
url = {http://link.springer.com/chapter/10.1007/3-540-46584-7{\_}2},
year = {2000}
}
@article{Courtney2001,
author = {Courtney, A},
journal = {Practical Aspects of Declarative Languages},
title = {{Frapp{\'{e}}: Functional reactive programming in Java}},
url = {http://link.springer.com/chapter/10.1007/3-540-45241-9{\_}3},
year = {2001}
}
@article{Hudak2003,
author = {Hudak, P and Courtney, A and Nilsson, H and Peterson, J},
journal = {{\ldots}  Functional Programming},
title = {{Arrows, robots, and functional reactive programming}},
url = {http://link.springer.com/content/pdf/10.1007/978-3-540-44833-4{\_}6},
year = {2003}
}
@article{Wan2000,
author = {Wan, Zhanyong and Hudak, Paul},
doi = {10.1145/358438.349331},
isbn = {1-58113-199-2},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {may},
number = {5},
pages = {242--252},
publisher = {ACM},
title = {{Functional reactive programming from first principles}},
url = {http://dl.acm.org/citation.cfm?id=358438.349331},
volume = {35},
year = {2000}
}
@article{Hudak1999,
author = {Hudak, P},
journal = {Programming Languages and Systems},
keywords = {Paul Hudak},
title = {{Functional reactive programming}},
url = {http://link.springer.com/content/pdf/10.1007/3-540-49099-X{\_}1.pdf http://link.springer.com/chapter/10.1007/3-540-49099-X{\_}1},
year = {1999}
}
@article{Winograd-Cort2012,
author = {Winograd-Cort, D and Liu, H and Hudak, P},
journal = {Practical Aspects of Declarative  {\ldots}},
title = {{Virtualizing real-world objects in FRP}},
url = {http://link.springer.com/chapter/10.1007/978-3-642-27694-1{\_}17},
year = {2012}
}
@article{Maraffi,
author = {Maraffi, C and Seagal, D},
journal = {users.soe.ucsc.edu},
title = {{Leveling Up: Could Functional Programming Be a Game Changer?}},
url = {http://users.soe.ucsc.edu/{~}topherm/CMPS203{\_}FRPSurvey{\_}MaraffiSeagal.pdf},
year = {2011}
}
@article{Winograd-Cort2013,
author = {Winograd-Cort, Daniel and Hudak, Paul},
doi = {10.1145/2430532.2364519},
isbn = {978-1-4503-1574-6},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {arrows,causality,functional reactive programming,resource types,side effects,stream processing},
month = {jan},
number = {12},
pages = {91},
publisher = {ACM},
title = {{Wormholes: Introducing Effects to FRP}},
url = {http://dl.acm.org/citation.cfm?id=2430532.2364519},
volume = {47},
year = {2013}
}
@article{Elliott2009,
abstract = {Functional reactive programming (FRP) has simple and powerful semantics, but has resisted efficient implementation. In particular, most past implementations have used demand-driven sampling, which accommodates FRP's continuous time semantics and fits well with the nature of functional programming. Consequently, values are wastefully recomputed even when inputs don't change, and reaction latency can be as high as the sampling period. This paper presents a way to implement FRP that combines data- and demand-driven evaluation, in which values are recomputed only when necessary, and reactions are nearly instantaneous. The implementation is rooted in a new simple formulation of FRP and its semantics and so is easy to understand and reason about. On the road to a new implementation, we'll meet some old friends (monoids, functors, applicative functors, monads, morphisms, and improving values) and make some new friends (functional future values, reactive normal form, and concurrent "unambiguous choice").},
author = {Elliott, CM},
institution = {ACM},
isbn = {9781605585086},
journal = {Proceedings of the 2nd ACM SIGPLAN symposium on {\ldots}},
keywords = {a finite,because can,before being clipped,concur,data driven,demand driven,finite counterparts,functional reactive programming,more composable than,rency,scaled arbitrarily time,semantics,space},
number = {January},
pages = {25},
publisher = {ACM Press},
series = {Haskell '09},
title = {{Push-pull functional reactive programming}},
url = {http://portal.acm.org/citation.cfm?doid=1596638.1596643 http://dl.acm.org/citation.cfm?id=1596643},
volume = {96},
year = {2009}
}
@article{Elliott1997,
author = {Elliott, C and Hudak, Paul},
journal = {ACM SIGPLAN Notices},
title = {{Functional reactive animation}},
url = {http://dl.acm.org/citation.cfm?id=258973},
year = {1997}
}
@article{Miller2013,
author = {Miller, H and Haller, P},
file = {::},
journal = {Workshop on Reactivity, Events and {\ldots}},
title = {{RAY: Integrating Rx and Async for Direct-Style Reactive Streams}},
url = {http://infoscience.epfl.ch/record/188383/},
year = {2013}
}
@article{Amsden2011,
abstract = {Functional Reactive Programming (FRP) provides a conceptual framework for implementing reactive systems. It is a relatively re- cent model of programming, but has already been explored, im- plemented, and optimized in several useful ways. We survey the literature on FRP, its implementation, optimization, and uses, and present ideas for further research, along with some examples.},
author = {Amsden, E},
file = {:home/etn/Documents/PhD/Biblio/Amsden - 2011 - A survey of functional reactive programming.pdf:pdf},
journal = {Unpublished},
keywords = {denotational,functional,programming,reactive},
title = {{A survey of functional reactive programming}},
url = {http://www.cs.rit.edu/{~}eca7215/frp-independent-study/Survey.pdf},
volume = {54},
year = {2011}
}
@article{Maier,
author = {Maier, I},
file = {::},
journal = {soft.vub.ac.be},
title = {{Reactive Lenses}},
url = {http://soft.vub.ac.be/REM13/papers/rem20130{\_}submission{\_}10.pdf}
}
@article{Jeffrey2013,
author = {Jeffrey, Alan},
doi = {10.1145/2544174.2500584},
isbn = {978-1-4503-2326-0},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {concurrency,functional reactive programming,liveness},
month = {nov},
number = {9},
pages = {233--244},
publisher = {ACM},
title = {{Functional reactive programming with liveness guarantees}},
url = {http://dl.acm.org/citation.cfm?id=2544174.2500584},
volume = {48},
year = {2013}
}
@misc{Huber,
author = {Huber, Val},
booktitle = {Slashdot},
title = {{Why Reactive Programming for Databases is Awesome}},
url = {http://slashdot.org/topic/bi/why-reactive-programming-for-databases-is-awesome/}
}
@book{Klop1990,
author = {Klop, JW},
title = {{Term rewriting systems}},
url = {http://www.informatik.uni-bremen.de/agbkb/lehre/rbs/texte/Klop-TR.pdf},
year = {1990}
}
@article{YaleHaskellGroup2010,
abstract = {Yampa is a domain-specific embedded language for the programming of hybrid (discrete and continuous time) systems using the concepts of Functional Reactive Programming (FRP). Yampa is structured using Arrows, which greatly reduce the chance of introducing space- and time-leaks into reactive, time-varying systems.},
author = {{Yale Haskell Group}},
title = {{Yampa}},
url = {http://www.haskell.org/haskellwiki/Yampa},
year = {2010}
}
@article{Brus1987a,
author = {Brus, TH and van Eekelen, MCJD},
journal = {{\ldots} and Computer {\ldots}},
title = {{Clean—a language for functional graph rewriting}},
url = {http://link.springer.com/chapter/10.1007/3-540-18317-5{\_}20},
year = {1987}
}
@article{Krishnaswami2012a,
author = {Krishnaswami, NR and Benton, N and Hoffmann, J},
journal = {ACM SIGPLAN Notices},
title = {{Higher-order functional reactive programming in bounded space}},
url = {http://dl.acm.org/citation.cfm?id=2103665},
year = {2012}
}
@article{Jeffrey2012,
author = {Jeffrey, A},
journal = {Proceedings of the sixth workshop on Programming  {\ldots}},
title = {{LTL types FRP: Linear-time temporal logic propositions as types, proofs as functional reactive programs}},
url = {http://dl.acm.org/citation.cfm?id=2103783},
year = {2012}
}
@article{Jeltsch2012,
author = {Jeltsch, W},
journal = {Electronic Notes in Theoretical Computer Science},
title = {{Towards a common categorical semantics for linear-time temporal logic and functional reactive programming}},
url = {http://www.sciencedirect.com/science/article/pii/S157106611200045X},
year = {2012}
}
@article{Berry1984b,
author = {Berry, G and Cosserat, L},
title = {{The Esterel synchronous programming language and its mathematical semantics}},
url = {http://hal.inria.fr/docs/00/07/62/30/PDF/RR-0327.pdf},
year = {1984}
}
@article{Courtney2003,
author = {Courtney, A and Nilsson, H and Peterson, J},
journal = {Proceedings of the 2003 ACM  {\ldots}},
title = {{The yampa arcade}},
url = {http://dl.acm.org/citation.cfm?id=871897},
year = {2003}
}
@article{Wan2002,
author = {Wan, Z and Taha, W and Hudak, P},
journal = {Practical Aspects of Declarative Languages},
title = {{Event-driven FRP}},
url = {http://link.springer.com/chapter/10.1007/3-540-45587-6{\_}11},
year = {2002}
}
@article{Wan2001,
author = {Wan, Z and Taha, W and Hudak, P},
journal = {ACM SIGPLAN Notices},
title = {{Real-time FRP}},
url = {http://dl.acm.org/citation.cfm?id=507654},
year = {2001}
}
@article{Peterson2001,
author = {Peterson, J and Hudak, P and Reid, A and Hager, G},
journal = {{\ldots}  Aspects of Declarative Languages},
title = {{FVision: A declarative language for visual tracking}},
url = {http://link.springer.com/chapter/10.1007/3-540-45241-9{\_}21},
year = {2001}
}
@article{Courtney2001a,
author = {Courtney, A and Elliott, C},
journal = {Haskell Workshop},
title = {{Genuinely functional user interfaces}},
url = {http://webdoc.sub.gwdg.de/ebook/serien/ah/UU-CS/2001-62.pdf{\#}page=47},
year = {2001}
}
@article{Reid1999,
author = {Reid, A and Peterson, J and Hager, G and Hudak, P},
journal = {Proceedings of the 21st {\ldots}},
title = {{Prototyping real-time vision systems: An experiment in DSL design}},
url = {http://dl.acm.org/citation.cfm?id=302681},
year = {1999}
}
@misc{Paananen2012,
abstract = {A small functional reactive programming lib for JavaScript. Turns your event spaghetti into clean and declarative feng shui bacon, by switching from imperative to functional. It's like replacing nested for-loops with functional programming concepts like map and filter. Stop working on individual events and work with event streams instead. Transform your data with map and filter. Combine your data with merge and combine. Then switch to the heavier weapons and wield flatMap and combineTemplate like a boss.},
author = {Paananen, Juha},
title = {{Bacon.js}},
url = {https://github.com/baconjs/bacon.js},
year = {2012}
}
@article{Peterson1998,
author = {Peterson, J and Hudak, P and Elliott, C},
journal = {Practical Aspects of Declarative {\ldots}},
title = {{Lambda in motion: Controlling robots with Haskell}},
url = {http://link.springer.com/chapter/10.1007/3-540-49201-1{\_}7},
year = {1998}
}
@article{Elliott1997a,
author = {Elliott, C},
journal = {DSL},
title = {{Modeling Interactive 3D and Multimedia Animation with an Embedded Language.}},
url = {http://www.usenix.org/publications/library/proceedings/dsl97/full{\_}papers/elliott/elliott{\_}html/elliott.html},
year = {1997}
}
@misc{Elliott,
author = {Elliott, Conal M.},
booktitle = {Stackoverflow.com},
title = {{FRP explanation}},
url = {http://stackoverflow.com/a/1030631/933670},
year = {2009}
}
@article{McCarthy1959,
author = {McCarthy, J},
file = {:home/etn/Documents/PhD/Biblio/McCarthy - 1959 - Lisp a programming system for symbolic manipulations.pdf:pdf},
journal = {ACM},
title = {{Lisp: a programming system for symbolic manipulations}},
url = {http://ufr6.univ-paris8.fr/Math/spip/IMG/pdf/p32-mccarthy.pdf},
year = {1959}
}
@article{Sussman1998,
abstract = {Inspired byACTORS[7, 17], we have implemented an interpreter for a LISP-like language, SCHEME, based on the lambda calculus [2], but extended for side effects, multiprocessing, and process synchronization. The purpose of this implementation is tutorial. We wish to: 1. alleviate the confusion caused by Micro-PLANNER, CONNIVER, etc., by clarifying the embedding of non-recursive control structures in a recursive host language like LISP. 2. explain how to use these control structures, independent of such issues as pattern matching and data base manipulation. 3. have a simple concrete experimental domain for certain issues of programming semantics and style. This paper is organized into sections. The first section is a short “reference manual” containing specifications for all the unusual features of SCHEME. Next, we present a sequence of programming examples which illustrate various programming styles, and how to use them. This will raise certain issues of semantics which we will try to clarify with lambda calculus in the third section. In the fourth section we will give a general discussion of the issues facing an implementor of an interpreter for a language based on lambda calculus. Finally, we will present a completely annotated interpreter for SCHEME, written in MacLISP [13], to acquaint programmers with the tricks of the trade of implementing non-recursive control structures in a recursive language like LISP. This report describes research done at the Artificial Intelligence Laboratory of the Massachusetts Institute of Technology. Support for the laboratory’s artificial intelligence research is provided in part by the Advanced Research Projects Agency of the Department of Defense under Office of Naval Research contract N00014-75-C- 0643. 1.},
author = {Sussman, Gerald Jay and {Steele, Guy L}, Jr},
doi = {10.1023/A:1010035624696},
file = {:home/etn/Documents/PhD/Biblio/Sussman, Steele, Guy L - 1998 - Scheme A interpreter for extended lambda calculus.pdf:pdf},
issn = {13883690},
journal = {Higher-Order and Symbolic Computation},
keywords = {11,1998,405,439,boston,c 1998 kluwer academic,her-order and symbolic computation,manufactured in the netherlands,publishers},
pages = {405--439},
title = {{Scheme: A interpreter for extended lambda calculus}},
url = {http://link.springer.com/article/10.1023/A:1010035624696},
volume = {11},
year = {1998}
}
@article{Hughes1989,
abstract = {As software becomes more and more complex, it is more and more important to structure it well. Well-structured software is easy to write, easy to debug, and provides a collection of modules that can be re-used to reduce future programming costs. Conventional languages place con- ceptual limits on the way problems can be modularised. Functional lan- guages push those limits back. In this paper we show that two features of functional languages in particular, higher-order functions and lazy eval- uation, can contribute greatly to modularity. As examples, we manipu- late lists and trees, program several numerical algorithms, and implement the alpha-beta heuristic (an algorithm from Artificial Intelligence used in game-playing programs). Since modularity is the key to successful pro- gramming, functional languages are vitally important to the real world.},
author = {Hughes, John},
doi = {10.1093/comjnl/32.2.98},
file = {:home/etn/Documents/PhD/Biblio/Hughes - 1989 - Why functional programming matters.pdf:pdf},
isbn = {0201172364},
issn = {0010-4620},
journal = {The computer journal},
number = {April 1989},
pages = {1--23},
title = {{Why functional programming matters}},
url = {https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf http://comjnl.oxfordjournals.org/content/32/2/98.short},
volume = {32},
year = {1989}
}
@article{Hudak1992,
author = {Hudak, Paul and Johnsson, Thomas and Kieburtz, Dick and Nikhil, Rishiyur and Partain, Will and Peterson, John and {Peyton Jones}, Simon and Wadler, Philip and Boutel, Brian and Fairbairn, Jon and Fasel, Joseph and Guzman, Maria M. and Hammond, Kevin and Hughes, John},
doi = {10.1145/130697.130699},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {Haskell},
mendeley-tags = {Haskell},
month = {may},
number = {5},
pages = {1--164},
publisher = {ACM},
title = {{Report on the programming language Haskell}},
url = {http://dl.acm.org/citation.cfm?id=130697.130699},
volume = {27},
year = {1992}
}
@article{Turner1986,
author = {Turner, D},
doi = {10.1145/15042.15053},
file = {:home/etn/Documents/PhD/Biblio/Turner - 1986 - An overview of Miranda.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {dec},
number = {12},
pages = {158--166},
publisher = {ACM},
title = {{An overview of Miranda}},
url = {http://dl.acm.org/citation.cfm?id=15042.15053},
volume = {21},
year = {1986}
}
@book{Milner1997,
abstract = {Standard ML is a general-purpose programming language designed for large projects. This book provides a formal definition of Standard ML for the benefit of all concerned with the language, including users and implementers. Because computer programs are increasingly required to withstand rigorous analysis, it is all the more important that the language in which they are written be defined with full rigor.The Definition of Standard ML is the essential point of reference for Standard ML. Since its publication in 1990, the implementation technology of the language has advanced enormously and the number of users has grown. The revised edition includes a number of new features, omits little-used features, and corrects mistakes of definition.},
author = {Milner, R. and Tofte, Mads and Harper, Robert and MacQueen, David},
file = {:home/etn/Documents/PhD/Biblio/Milner et al. - 1997 - The Definition of Standard ML - Revised.pdf:pdf},
isbn = {0262631814},
pages = {128},
title = {{The Definition of Standard ML - Revised}},
url = {https://mitpress.mit.edu/index.php?q=books/definition-standard-ml/ http://www.amazon.com/Definition-Standard-ML-Revised/dp/0262631814},
year = {1997}
}
@article{Rees1986,
author = {Rees, J and Clinger, W},
doi = {10.1145/15042.15043},
file = {:home/etn/Documents/PhD/Biblio/Rees, Clinger - 1986 - Revised report on the algorithmic language scheme.pdf:pdf},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {dec},
number = {12},
pages = {37--79},
publisher = {ACM},
title = {{Revised report on the algorithmic language scheme}},
url = {http://dl.acm.org/citation.cfm?id=15042.15043},
volume = {21},
year = {1986}
}
@inproceedings{Turner1981,
address = {New York, New York, USA},
author = {Turner, D. A.},
booktitle = {Proceedings of the 1981 conference on Functional programming languages and computer architecture - FPCA '81},
doi = {10.1145/800223.806766},
file = {:home/etn/Documents/PhD/Biblio/Turner - 1981 - The semantic elegance of applicative languages.pdf:pdf},
isbn = {0897910605},
month = {oct},
pages = {85--92},
publisher = {ACM Press},
title = {{The semantic elegance of applicative languages}},
url = {http://dl.acm.org/citation.cfm?id=800223.806766},
year = {1981}
}
@book{Sussman1983,
abstract = {Abelson and Sussman's classic "Structure and Interpretation of Computer Programs" teaches readers how to program by employing the tools of abstraction and modularity. The authors' central philosophy is that programming is the task of breaking large problems into small ones. The book spends a great deal of time considering both this decomposition and the process of knitting the smaller pieces back together. The authors employ this philosophy in their writing technique. The text asks the broad question "What is programming?" Having come to the conclusion that programming consists of procedures and data, the authors set off to explore the related questions of "What is data?" and "What is a procedure?" The authors build up the simple notion of a procedure to dizzying complexity. The discussion culminates in the description of the code behind the programming language Scheme. The authors finish with examples of how to implement some of the book's concepts on a register machine. Through this journey, the reader not only learns how to program, but also how to think about programming. This edition available only OUTSIDE the U.S. and Canada},
author = {Abelson, H and Sussman, G J and Sussman, J},
booktitle = {{\_}imp03},
doi = {10.2307/3679579},
isbn = {0262010771},
issn = {01489267},
keywords = {textbook},
number = {3},
pages = {81},
title = {{The Structure and Interpretation of Computer Programs}},
url = {http://books-are-me.info/wp-content/uploads/pdfs/Structure and Interpretation of Computer Programs Second Edition by Julie Sussman - Computer ScienceArt.pdf citeulike-article-id:278800$\backslash$nhttp://www.amazon.ca/exec/obidos/redirect?tag=citeulike09-20{\&}amp$\backslash$npat},
volume = {9},
year = {1985}
}
@article{Czaplicki2013,
annote = {From Duplicate 2 (Asynchronous functional reactive programming for GUIs - Czaplicki, Evan; Chong, Stephen)

Elm},
author = {Czaplicki, Evan and Chong, Stephen},
doi = {10.1145/2499370.2462161},
file = {:home/etn/Documents/PhD/Biblio/Czaplicki, Chong - 2013 - Asynchronous functional reactive programming for GUIs.pdf:pdf},
isbn = {978-1-4503-2014-6},
issn = {03621340},
journal = {{\ldots} 34th ACM SIGPLAN conference on Programming {\ldots}},
keywords = {functional reactive programming,graphical user interfaces},
month = {jun},
number = {6},
pages = {411},
publisher = {ACM},
title = {{Asynchronous functional reactive programming for GUIs}},
url = {http://dl.acm.org/citation.cfm?id=2462161 http://dl.acm.org/citation.cfm?id=2499370.2462161},
volume = {48},
year = {2013}
}
