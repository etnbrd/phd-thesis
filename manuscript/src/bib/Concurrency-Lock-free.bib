Automatically generated by Mendeley Desktop 1.16-dev2
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@incollection{Cong2005,
abstract = {Lock-free shared data structures in the setting of distributed computing have received a fair amount of attention. Major motivations of lock-free data structures include increasing fault tolerance of a (possibly heterogeneous) system and alleviating the problems associated with critical sections such as priority inversion and deadlock. For parallel computers with tightly-coupled processors and shared memory, these issues are no longer major concerns. While many of the results are applicable especially when the model used is shared memory multiprocessors, no prior studies have considered improving the performance of a parallel implementation by way of lock-free programming. As a matter of fact, often times in practice lock-free data structures in a distributed setting do not perform as well as those that use locks. As the data structures and algorithms for parallel computing are often drastically different from those in distributed computing, it is possible that lock-free programs perform better. In this paper we compare the similarity and difference of lock-free programming in both distributed and parallel computing environments and explore the possibility of adapting lock-free programming to parallel computing to improve performance. Lock-free programming also provides a new way of simulating PRAM and asynchronous PRAM algorithms on current parallel machines.},
author = {Cong, Guojing and Bader, David},
booktitle = {Lecture Notes in Computer Science, Volume 3296/2005},
doi = {10.1007/978-3-540-30474-6{\_}54},
file = {:home/etn/Documents/PhD/Biblio/Cong, Bader - 2005 - Lock-Free Parallel Algorithms An Experimental Study.pdf:pdf},
pages = {1873--1875},
title = {{Lock-Free Parallel Algorithms: An Experimental Study}},
url = {http://www.cc.gatech.edu/{~}bader/papers/lockfree-HiPC2004.pdf http://www.springerlink.com/content/xw2v4a7h74j8ykhp/},
volume = {3296},
year = {2005}
}
@article{Sundell2003,
abstract = {We present an efficient and practical lock-free implementation of a concurrent priority queue that is suitable for both fully concurrent (large multi-processor) systems as well as pre-emptive (multi-process) systems. Many algorithms for concurrent priority queues are based on mutual exclusion. However, mutual exclusion causes blocking which has several drawbacks and degrades the system's overall performance. Non-blocking algorithms avoid blocking, and are either lock-free or wait-free. Previously known non-blocking algorithms of priority queues did not perform well in practice because of their complexity, and they are often based on non-available atomic synchronization primitives. Our algorithm is based on the randomized sequential list structure called Skiplist, and a real-time extension of our algorithm is also described. In our performance evaluation we compare our algorithm with some of the most efficient implementations of priority queues known. The experimental results clearly show that our lock-free implementation outperforms the other lock-based implementations in all cases for 3 threads and more, both on fully concurrent as well as on pre-emptive systems.},
author = {Sundell, H. and Tsigas, P.},
doi = {10.1109/IPDPS.2003.1213189},
file = {:home/etn/Documents/PhD/Biblio/Sundell, Tsigas - 2003 - Fast and lock-free concurrent priority queues for multi-thread systems.pdf:pdf},
isbn = {0-7695-1926-1},
issn = {07437315},
journal = {Proceedings International Parallel and Distributed Processing Symposium},
number = {C},
pages = {11},
title = {{Fast and lock-free concurrent priority queues for multi-thread systems}},
url = {http://www.non-blocking.com/download/SunT03{\_}PQueue{\_}TR.pdf http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=1213189},
volume = {00},
year = {2003}
}
@article{Niu2011,
abstract = {Stochastic Gradient Descent (SGD) is a popular algorithm that can achieve state-of-the-art performance on a variety of machine learning tasks. Several researchers have recently proposed schemes to parallelize SGD, but all require performance-destroying memory locking and synchronization. This work aims to show using novel theoretical analysis, algorithms, and implementation that SGD can be implemented without any locking. We present an update scheme called HOGWILD! which allows processors access to shared memory with the possibility of overwriting each other's work. We show that when the associated optimization problem is sparse, meaning most gradient updates only modify small parts of the decision variable, then HOGWILD! achieves a nearly optimal rate of convergence. We demonstrate experimentally that HOGWILD! outperforms alternative schemes that use locking by an order of magnitude.},
archivePrefix = {arXiv},
arxivId = {1106.5730},
author = {Niu, Feng and Recht, Benjamin and Re, Christopher and Wright, Stephen J.},
eprint = {1106.5730},
file = {:home/etn/Documents/PhD/Biblio/Niu et al. - 2011 - HOGWILD! A Lock-Free Approach to Parallelizing Stochastic Gradient Descent.pdf:pdf},
isbn = {9781618395993},
journal = {Advances in Neural Information Processing Systems},
number = {1},
pages = {21},
title = {{HOGWILD!: A Lock-Free Approach to Parallelizing Stochastic Gradient Descent}},
url = {http://i.stanford.edu/hazy/papers/hogwild-nips.pdf http://arxiv.org/abs/1106.5730},
year = {2011}
}
@misc{Anderson1990,
author = {Anderson, James H. and Gouda, Mohamed G.},
file = {:home/etn/Documents/PhD/Biblio/Anderson, Gouda - 1990 - The virtue of Patience Concurrent Programming With And Without Waiting.pdf:pdf},
title = {{The virtue of Patience: Concurrent Programming With And Without Waiting}},
url = {http://www.cs.utexas.edu/ftp/techreports/tr90-23.pdf},
year = {1990}
}
@article{Herlihy1990,
author = {Herlihy, M.},
doi = {10.1145/99164.99185},
file = {:home/etn/Documents/PhD/Biblio/Herlihy - 1990 - A methodology for implementing highly concurrent data structures.pdf:pdf},
isbn = {0-89791-350-7},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
month = {mar},
number = {3},
pages = {197--206},
publisher = {ACM},
title = {{A methodology for implementing highly concurrent data structures}},
url = {http://dl.acm.org/citation.cfm?id=99164.99185},
volume = {25},
year = {1990}
}
@article{Lamport1977,
author = {Lamport, Leslie},
doi = {10.1145/359863.359878},
file = {:home/etn/Documents/PhD/Biblio/Lamport - 1977 - Concurrent reading and writing.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {asynchronous multiprocessing,multiprocess synchronization,readers/writers problem,shared data},
month = {nov},
number = {11},
pages = {806--811},
publisher = {ACM},
title = {{Concurrent reading and writing}},
url = {http://dl.acm.org/citation.cfm?id=359863.359878},
volume = {20},
year = {1977}
}
@inproceedings{Herlihy1988,
address = {New York, New York, USA},
author = {Herlihy, Maurice P.},
booktitle = {Proceedings of the seventh annual ACM Symposium on Principles of distributed computing - PODC '88},
doi = {10.1145/62546.62593},
file = {:home/etn/Documents/PhD/Biblio/Herlihy - 1988 - Impossibility and universality results for wait-free synchronization.pdf:pdf},
isbn = {0897912772},
month = {jan},
pages = {276--290},
publisher = {ACM Press},
title = {{Impossibility and universality results for wait-free synchronization}},
url = {http://dl.acm.org/citation.cfm?id=62546.62593},
year = {1988}
}
@article{Harris2010,
abstract = {Abstract The advent of multicore processors has renewed interest in the idea of incorporating transactions into the programming model used to write parallel programs. This approach, known as transactional memory, offers an alternative, and hopefully better, way to coordinate concurrent threads. The ACI (atomicity, consistency, isolation) properties of transactions provide a foundation to ensure that concurrent reads and writes of shared data do not produce inconsistent or incorrect results. At a higher level, a computation wrapped in a transaction executes atomically - either it completes successfully and commits its result in its entirety or it aborts. In addition, isolation ensures the transaction produces the same result as if no other transactions were executing concurrently. Although transactions are not a parallel programming panacea, they shift much of the burden of synchronizing and coordinating parallel computations from a programmer to a compiler, to a language runtime system, or to hardware. Th...},
author = {Harris, Tim and Larus, James and Rajwar, Ravi},
doi = {10.2200/S00272ED1V01Y201006CAC011},
issn = {1935-3235},
journal = {Synthesis Lectures on Computer Architecture},
keywords = {cache coherence,compilers,computer architecture,computer hardware,concurrent programming,lock-free data structures,nonblocking algorithms,parallel programming,programming languages,synchronization,transactional memory},
language = {en},
month = {dec},
number = {1},
pages = {1--263},
publisher = {Morgan {\&} Claypool Publishers},
title = {{Transactional Memory, 2nd edition}},
url = {http://www.morganclaypool.com/doi/abs/10.2200/s00272ed1v01y201006cac011},
volume = {5},
year = {2010}
}
@inproceedings{Valois1995,
address = {New York, New York, USA},
author = {Valois, John D.},
booktitle = {Proceedings of the fourteenth annual ACM symposium on Principles of distributed computing - PODC '95},
doi = {10.1145/224964.224988},
isbn = {0897917103},
month = {aug},
pages = {214--222},
publisher = {ACM Press},
title = {{Lock-free linked lists using compare-and-swap}},
url = {http://dl.acm.org/citation.cfm?id=224964.224988},
year = {1995}
}
@article{Herlihy1991,
abstract = {A wait-free implementation of a concurrent data object is one that guarantees that any process can complete any operation in a finite number of steps, regardless of the execution speeds of the other processes. The problem of constructing a wait-free implementation of one data object from another lies at the heart of much recent work in concurrent algorithms, concurrent data structures, and multiprocessor architectures. First, we introduce a simple and general technique, based on reduction to a concensus protocol, for proving statements of the form, there is no wait-free implementation of X by Y. We derive a hierarchy of objects such that no object at one level has a wait-free implementation in terms of objects at lower levels. In particular, we show that atomic read/write registers, which have been the focus of much recent attention, are at the bottom of the hierarchy: thay cannot be used to construct wait-free implementations of many simple and familiar data types. Moreover, classical synchronization primitives such astest{\&}set and fetch{\&}add, while more powerful than read and write, are also computationally weak, as are the standard message-passing primitives. Second, nevertheless, we show that there do exist simple universal objects from which one can construct a wait-free implementation of any sequential object.},
author = {Herlihy, Maurice},
doi = {10.1145/114005.102808},
file = {:home/etn/Documents/PhD/Biblio/Herlihy - 1991 - Wait-free synchronization.pdf:pdf},
isbn = {9780123705914},
issn = {01640925},
journal = {ACM Transactions on Programming Languages and Systems},
keywords = {linearization,wait-free synchronization},
month = {jan},
number = {1},
pages = {124--149},
publisher = {ACM},
title = {{Wait-free synchronization}},
url = {http://dl.acm.org/citation.cfm?id=114005.102808 http://cs.brown.edu/{~}mph/Herlihy91/p124-herlihy.pdf},
volume = {13},
year = {1991}
}
@inproceedings{Hendler2004,
address = {New York, New York, USA},
author = {Hendler, Danny and Shavit, Nir and Yerushalmi, Lena},
booktitle = {Proceedings of the sixteenth annual ACM symposium on Parallelism in algorithms and architectures - SPAA '04},
doi = {10.1145/1007912.1007944},
isbn = {1581138407},
month = {jun},
pages = {206},
publisher = {ACM Press},
title = {{A scalable lock-free stack algorithm}},
url = {http://dl.acm.org/citation.cfm?id=1007912.1007944},
year = {2004}
}
@inproceedings{Wimmer2015,
address = {New York, New York, USA},
author = {Wimmer, Martin and Gruber, Jakob and Tr{\"{a}}ff, Jesper Larsson and Tsigas, Philippas},
booktitle = {Proceedings of the 20th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming - PPoPP 2015},
doi = {10.1145/2688500.2688547},
isbn = {9781450332057},
keywords = {Task-parallel programming,concurrent data structure relaxation,priority-queue,shared memory},
month = {jan},
pages = {277--278},
publisher = {ACM Press},
title = {{The lock-free k-LSM relaxed priority queue}},
url = {http://dl.acm.org/citation.cfm?id=2688500.2688547},
year = {2015}
}
@inproceedings{Ramachandran2015,
address = {New York, New York, USA},
author = {Ramachandran, Arunmoezhi and Mittal, Neeraj},
booktitle = {Proceedings of the 2015 International Conference on Distributed Computing and Networking - ICDCN '15},
doi = {10.1145/2684464.2684472},
isbn = {9781450329286},
keywords = {Binary,Concurrent Data Structure,Lock-Free Algorithm,Search Tree},
month = {jan},
pages = {1--10},
publisher = {ACM Press},
title = {{A Fast Lock-Free Internal Binary Search Tree}},
url = {http://dl.acm.org/citation.cfm?id=2684464.2684472},
year = {2015}
}
@inproceedings{Timnat2012,
abstract = {The linked-list data structure is fundamental and ubiquitous. Lock-free versions of the linked-list are well known. However, the existence of a practical wait-free linked-list has been open. In this work we designed such a linked-list. To achieve better performance, we have also extended this design using the fast-path-slow-path methodology. The resulting implementation achieves performance which is competitive with that of Harris’s lock-free list, while still guaranteeing non-starvation via wait-freedom.We have also developed a proof for the correctness and the wait-freedom of our design.},
author = {Timnat, Shahar and Braginsky, Anastasia and Kogan, Alex and Petrank, Erez},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-35476-2{\_}23},
isbn = {9783642354755},
issn = {03029743},
pages = {330--344},
title = {{Wait-free linked-lists}},
url = {http://www.cs.technion.ac.il/{~}erez/Papers/wfll-short.pdf},
volume = {7702 LNCS},
year = {2012}
}
