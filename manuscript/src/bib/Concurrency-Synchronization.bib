Automatically generated by Mendeley Desktop 1.16-dev2
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@inproceedings{Yoo2011,
abstract = {As networking services, such as DHTs, provide increasingly complex functionality, providing acceptable performance will require parallelizing their operations on individual nodes. Unfortunately, the event-driven style in which these appli- cations have traditionally been written makes it dicult to reason about parallelism, and providing safe, ecient paral- lel implementations of distributed systems remains a chal- lenge. In this paper, we introduce a declarative program- ming model based on contexts, which allows programmers to specify the sharing behavior of event handlers. Programs that adhere to the programming model can be safely paral- lelized according to an abstract execution model, with paral- lel behavior that is well-de ned with respect to the expected sequential behavior. The declarative nature of the program- ming model allows conformance to be captured as a safety property that can be veri ed using a model checker. We develop a prototype implementation of our abstract execution model and show that distributed applications writ- ten in our programming model can be automatically and eciently parallelized. To recover additional parallelism, we present an optimization to the implementation based on state snapshots that permits more events to proceed in paral- lel. We evaluate our prototype implementation through sev- eral case studies and demonstrate signi cant speedup over optimized sequential implementations.},
address = {New York, New York, USA},
author = {Yoo, Sunghwan and Lee, Hyojeong and Killian, Charles and Kulkarni, Milind},
booktitle = {HPDC},
doi = {10.1145/1996130.1996144},
file = {:home/etn/Documents/PhD/Biblio/Yoo et al. - 2011 - InContext Simple Parallelism for Distributed Applications Categories and Subject Descriptors.pdf:pdf},
isbn = {9781450305525},
keywords = {all or part of,distributed programming,is granted without fee,mace,or hard copies of,permission to make digital,personal or classroom use,provided that copies are,this work for},
month = {jun},
pages = {97},
publisher = {ACM Press},
title = {{InContext : Simple Parallelism for Distributed Applications Categories and Subject Descriptors}},
url = {http://dl.acm.org/citation.cfm?id=1996130.1996144},
year = {2011}
}
@article{Rotem-Gal-Oz2006,
author = {Rotem-Gal-Oz, A},
journal = {{\ldots} http://www. rgoarchitects. com/Files/fallacies. {\ldots}},
title = {{Fallacies of distributed computing explained}},
url = {http://www.rgoarchitects.com/Files/fallacies.pdf},
year = {2006}
}
@book{Luckham2002,
author = {Luckham, DC},
title = {{The power of events}},
url = {https://sisis.rz.htw-berlin.de/inh2010/12375999.pdf},
year = {2002}
}
@article{Welsh2000,
abstract = {Building highly concurrent systems, such as large-scale Internet services, requires managing many information flows at once and maintaining peak throughput when demand exceeds resource availability. In addition, any platform supporting Internet services must provide high availability and be able to cope with burstiness of load. Many approaches to building concurrent systems have been proposed, which generally fall into the two categories of threaded and event- driven programming. We propose that threads and events are actually on the ends of a design spectrum, and that the best implementation strategy for these applications is somewhere in between. We present a general-purpose design framework for building highly concurrent systems, based on three design components — tasks, queues, and thread pools — which encapsulate the concurrency, performance, fault isolation, and software engineering benefits of both threads and events. We present a set of design patterns that can be applied to map an application onto an implementation using these components. In addition, we provide an analysis of several systems (including an Internet services platform and a highly available, distributed, persistent data store) constructed using our framework, demonstrating its benefit for building and reasoning about concurrent applications.},
author = {Welsh, Matt and Gribble, Steven D and Brewer, Eric a and Culler, David},
file = {:home/etn/Documents/PhD/Biblio/Welsh et al. - 2000 - A design framework for highly concurrent systems.pdf:pdf},
journal = {University of California, Berkeley},
keywords = {Event,SEDA},
mendeley-tags = {Event,SEDA},
title = {{A design framework for highly concurrent systems}},
url = {http://www.cs.berkeley.edu/{~}culler/papers/events.pdf http://www.cs.berkeley.edu/{~}culler/papers/events.pdf$\backslash$nhttp://www.eecs.harvard.edu/{~}mdw/papers/events.pdf},
year = {2000}
}
@article{Lauer1979,
author = {Lauer, HC and Needham, RM},
file = {:home/etn/Documents/PhD/Biblio/Lauer, Needham - 1979 - On the duality of operating system structures.pdf:pdf},
journal = {ACM SIGOPS Operating Systems Review},
title = {{On the duality of operating system structures}},
url = {http://dl.acm.org/citation.cfm?id=850658},
year = {1979}
}
@article{Behren2003,
author = {von Behren, JR and Condit, J and Brewer, EA},
file = {:home/etn/Documents/PhD/Biblio/Behren, Condit, Brewer - 2003 - Why Events Are a Bad Idea (for High-Concurrency Servers).pdf:pdf},
journal = {HotOS},
title = {{Why Events Are a Bad Idea (for High-Concurrency Servers).}},
url = {http://static.usenix.org/publications/library/proceedings/hotos03/tech/full{\_}papers/vonbehren/vonbehren{\_}html/},
year = {2003}
}
@article{Ousterhout1996,
author = {Ousterhout, J},
file = {:home/etn/Documents/PhD/Biblio/Ousterhout - 1996 - Why threads are a bad idea (for most purposes).pdf:pdf},
journal = {Presentation given at the 1996 Usenix Annual Conference},
title = {{Why threads are a bad idea (for most purposes)}},
url = {http://chess.cs.umd.edu/class/spring2009/cmsc433/Lectures/threadVsEvents.pdf},
year = {1996}
}
@article{Adya2002,
author = {Adya, A and Howell, J and Theimer, M},
file = {:home/etn/Documents/PhD/Biblio/Adya, Howell, Theimer - 2002 - Cooperative Task Management Without Manual Stack Management.pdf:pdf},
journal = {USENIX Annual Technical Conference},
title = {{Cooperative Task Management Without Manual Stack Management.}},
url = {http://static.usenix.org/publications/library/proceedings/usenix02/full{\_}papers/adyahowell/adyahowell{\_}html/},
year = {2002}
}
@article{Behren2003a,
author = {Behren, R Von and Condit, J and Zhou, F},
file = {:home/etn/Documents/PhD/Biblio/Behren, Condit, Zhou - 2003 - Capriccio scalable threads for internet services.pdf:pdf},
journal = {ACM SIGOPS {\ldots}},
keywords = {Capriccio,Thread},
mendeley-tags = {Capriccio,Thread},
title = {{Capriccio: scalable threads for internet services}},
url = {http://dl.acm.org/citation.cfm?id=945471},
year = {2003}
}
@article{Gustafsson2005,
author = {Gustafsson, A},
file = {:home/etn/Documents/PhD/Biblio/Gustafsson - 2005 - Threads without the pain.pdf:pdf},
journal = {Queue},
title = {{Threads without the pain}},
url = {http://dl.acm.org/citation.cfm?id=1105678},
year = {2005}
}
@article{Krohn2007,
author = {Krohn, MN and Kohler, E and Kaashoek, MF},
file = {:home/etn/Documents/PhD/Biblio/Krohn, Kohler, Kaashoek - 2007 - Events Can Make Sense.pdf:pdf},
journal = {USENIX Annual Technical Conference},
keywords = {TAME,event},
mendeley-tags = {TAME,event},
title = {{Events Can Make Sense.}},
url = {https://www.usenix.org/legacy/events/usenix07/tech/full{\_}papers/krohn/krohn{\_}html/},
year = {2007}
}
@article{Gribble2001,
abstract = {The Ninja project seeks to enable the broad innovation of robust, scalable, distributed Internet services, and to permit the emerging class of extremely heterogeneous devices to seamlessly access these services. Our architecture consists of four basic elements: bases, which are powerful workstation cluster environments with a software platform that simplifies scalable service construction; units, which are the devices by which users access the services; active proxies, which are transformational elements that are used for unit- or service-specific adaptation; and paths, which are an abstraction through which units, services, and active proxies are composed.},
author = {Gribble, Steven D. and Welsh, Matt and {Von Behren}, Rob and Brewer, Eric a. and Culler, David and Borisov, N. and Czerwinski, S. and Gummadi, R. and Hill, J. and Joseph, A. and Katz, R. H. and Mao, Z. M. and Ross, S. and Zhao, B.},
doi = {10.1016/S1389-1286(00)00179-1},
file = {:home/etn/Documents/PhD/Biblio/Gribble, Welsh, Behren - 2001 - The Ninja architecture for robust Internet-scale systems and services.pdf:pdf},
isbn = {1389-1286},
issn = {13891286},
journal = {Computer Networks},
keywords = {distributed systems,ninja architecture,pervasive computing,scalable services,thin clients},
number = {4},
pages = {473--497},
title = {{Ninja architecture for robust Internet-scale systems and services}},
url = {http://www.sciencedirect.com/science/article/pii/S1389128600001791},
volume = {35},
year = {2001}
}
@misc{Pai1999,
abstract = {This paper presents the design of a new Web server architecture called the asymmetric multi-process event- driven (AMPED) architecture, and evaluates the perfor- mance of an implementation of this architecture, the Flash Web server. The Flash Web server combines the high performance of single-process event-driven servers on cached workloads with the performance of multi- process and multi-threaded servers on disk-bound work- loads. Furthermore, the Flash Web server is easily portable since it achieves these results using facilities available in all modern operating systems. The performance of different Web server architec- tures is evaluated in the context of a single implemen- tation in order to quantify the impact of a server’s con- currency architecture on its performance. Furthermore, the performance of Flash is compared with two widely- used Web servers, Apache and Zeus. Results indicate that Flash can match or exceed the performance of exist- ing Web servers by up to 50{\%} across a wide range of real workloads. We also present results that show the contri- bution of various optimizations embedded in Flash.},
author = {Pai, Vivek S and Druschel, Peter and Zwaenepoel, Willy},
booktitle = {Proceedings of the 1999 USENIX Annual Technical Conference},
doi = {10.1.1.119.6738},
file = {:home/etn/Documents/PhD/Biblio/Pai, Druschel, Zwaenepoel - 1999 - Flash An Efficient and Portable Web Server.pdf:pdf},
keywords = {Flash,event},
mendeley-tags = {Flash,event},
pages = {14},
title = {{Flash : An Efficient and Portable Web Server}},
url = {https://www.usenix.org/event/usenix99/full{\_}papers/pai/pai{\_}html/node7.html https://www.usenix.org/legacy/event/usenix99/full{\_}papers/pai/pai.pdf},
urldate = {2015-03-04},
year = {1999}
}
@article{Chandy2006,
author = {Chandy, KM},
file = {:home/etn/Documents/PhD/Biblio/Chandy - 2006 - Event-driven applications Costs, benefits and design approaches.pdf:pdf},
journal = {Gartner Application Integration and Web Services {\ldots}},
title = {{Event-driven applications: Costs, benefits and design approaches}},
url = {https://scholar.google.com/scholar?q=Event-Driven Applications: Costs, Benefits and Design Approaches{\&}btnG=Search{\&}as{\_}sdt=800000000001{\&}as{\_}sdtp=on{\#}0},
year = {2006}
}
@article{Reed2012,
author = {Reed, DP},
file = {:home/etn/Documents/PhD/Biblio/Reed - 2012 - Simultaneous Considered Harmful Modular Parallelism.pdf:pdf},
journal = {HotPar},
title = {{" Simultaneous" Considered Harmful: Modular Parallelism.}},
url = {https://scholar.google.com/scholar?q={\%}E2{\%}80{\%}9CSimultaneous{\%}E2{\%}80{\%}9D+Considered+Harmful{\%}3A+Modular+Parallelism{\&}btnG={\&}hl=en{\&}as{\_}sdt=0{\%}2C39{\#}0},
year = {2012}
}
@article{Hoare1974,
author = {Hoare, C. A. R.},
doi = {10.1145/355620.361161},
file = {:home/etn/Documents/PhD/Biblio/Hoare - 1974 - Monitors an operating system structuring concept.pdf:pdf},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {monitors,mutual exclusion,operating systems,scheduling,structured multiprogramming,synchronization,system implementation languages},
month = {oct},
number = {10},
pages = {549--557},
publisher = {ACM},
title = {{Monitors: an operating system structuring concept}},
url = {http://dl.acm.org/citation.cfm?id=355620.361161},
volume = {17},
year = {1974}
}
@article{Hansen1978a,
author = {Hansen, P.B. and Staunstrup, J.},
doi = {10.1109/TSE.1978.233856},
issn = {0098-5589},
journal = {IEEE Transactions on Software Engineering},
keywords = {Computer science,Concurrent programs,Delay,Programming profession,Specification languages,Sufficient conditions,guarded regions,mutual exclusion,program implementation,program specification,program verification,transition commands},
language = {English},
month = {sep},
number = {5},
pages = {365--370},
publisher = {IEEE},
title = {{Specification and Implementation of Mutual Exclusion}},
url = {http://ieeexplore.ieee.org/articleDetails.jsp?arnumber=1702551},
volume = {SE-4},
year = {1978}
}
@article{Dijkstra,
annote = {This is the reference paper for Semaphores.},
author = {Dijkstra, Edsger},
file = {:home/etn/Documents/PhD/Biblio/Dijkstra - Unknown - Over de sequentialiteit van procesbeschrijvingen.PDF:PDF},
title = {{Over de sequentialiteit van procesbeschrijvingen}}
}
@article{Reese2008,
author = {Reese, Will},
issn = {1075-3583},
journal = {Linux Journal},
month = {sep},
number = {173},
pages = {2},
publisher = {Belltown Media},
title = {{Nginx: the high-performance web server and reverse proxy}},
url = {http://dl.acm.org/ft{\_}gateway.cfm?id=1412204{\&}type=html},
volume = {2008},
year = {2008}
}
@inproceedings{Jr1990,
abstract = {We need a programming model that com- bines the advantages of the synchronous and asyn- chronous parallel styles. Synchronous programs are de- terminate (thus easier to reason about) and avoid syn- chronization overheads. Asynchronous programs are more flexible and handle conditionals more efficiently. Here we propose a programming model with the ben- efits of both styles. We allow asynchronous threads of control but restrict shared-memory accesses and other side effects so as to prevent the behavior of the program from depending on any accidents of execution order that can arise from the indeterminacy of the asynchronous process model. These restrictions may be enforced either dynam- ically (at run time) or statically (at compile time). In this paper we concentrate on dynamic enforcement, and exhibit an implementation of a parallel dialect of Scheme based on these ideas. A single successful exe- cution of a parallel program in this model constitutes a proof that the program is free of race conditions (for that particular set of input data). We also speculate on a design for a programming lan- guage using static enforcement. The notion of distinct- ness is important to proofs of noninterference. An ap- propriately designed programming language must sup port such concepts as “all the elements of this array are distinct,” perhaps through its type system. This parallel programming model does not support all styles of parallel programming, but we argue that it can support a large class of interesting algorithms with considerably greater efficiency (in some cases) than a strict SIMD approach and considerably greater safety (in all cases) than a full-blown MIMD approach.},
author = {Guy, L and Steele, Jr},
booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
doi = {10.1145/96709.96731},
file = {:home/etn/Documents/PhD/Biblio/Guy, Steele - 1990 - Making asynchronous parallelism safe for the world.pdf:pdf},
isbn = {0-89791-343-4},
issn = {07308566},
pages = {218--231},
title = {{Making asynchronous parallelism safe for the world}},
url = {http://dl.acm.org/citation.cfm?id=96731},
year = {1990}
}
@phdthesis{Randall1998,
abstract = {This thesis describes Cilk, a parallel multithreaded language for$\backslash$nprogramming contemporary shared memory multiprocessors (SMP's). Cilk$\backslash$nis a simple extension of C which provides constructs for parallel$\backslash$ncontrol and synchronization. Cilk imposes very low overheads--- the$\backslash$ntypical cost of spawning a parallel thread is only between 2 and$\backslash$n6 times the cost of a C function call on a variety of contemporary$\backslash$nmachines. Many Cilk programs run on one processor with virtually$\backslash$nno degradation compared to equivalent C programs. We present the$\backslash$n{\&}quot;work-first {\&}quot; principle which guided the design of Cilk's$\backslash$nscheduler and two consequences of this principle, a novel {\&}quot;two-clone{\&}quot;$\backslash$ncompilation strategy and a Dijkstra-like mutual-exclusion protocol$\backslash$nfor implementing the ready queue in the work-stealing scheduler.$\backslash$nTo facilitate debugging of Cilk programs, Cilk provides a tool called$\backslash$nthe Nondeterminator-2 which finds nondeterministic bugs called {\&}quot;data$\backslash$nraces{\&}quot;. We present two algorithms, All-Sets and Brelly, used$\backslash$nby the Nondeterminator-2 for finding data races. The All-Sets algorithm$\backslash$nis exact but can sometimes have poor performance; the Brelly algorithm,$\backslash$nby imposing a locking discipline on the programmer, is guaranteed},
author = {Randall, K.H.},
booktitle = {Engineering},
file = {:home/etn/Documents/PhD/Biblio/Randall - 1998 - Cilk Efficient Multithreaded Computing.pdf:pdf},
title = {{Cilk: Efficient Multithreaded Computing}},
url = {http://supertech.csail.mit.edu/papers/randall-phdthesis.pdf http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.139.6664{\&}amp;rep=rep1{\&}amp;type=pdf},
volume = {30},
year = {1998}
}
@article{Frigo1998,
abstract = {The fifth release of the multithreaded language Cilk uses a provably good "work-stealing" scheduling algorithm similar to the first system, but the language has been completely redesigned and the runtime system completely reengineered. The efficiency},
archivePrefix = {arXiv},
arxivId = {arXiv:gr-qc/9809069v1},
author = {Frigo, Matteo and Leiserson, Charles E. and Randall, Keith H.},
doi = {10.1145/277652.277725},
eprint = {9809069v1},
file = {:home/etn/Documents/PhD/Biblio/Frigo, Leiserson, Randall - 1998 - The implementation of the Cilk-5 multithreaded language.pdf:pdf},
isbn = {0897919874},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {critical path,ming language,multithreading,parallel computing,program-,runtime system,work},
month = {may},
number = {5},
pages = {212--223},
pmid = {15003161},
primaryClass = {arXiv:gr-qc},
publisher = {ACM},
title = {{The implementation of the Cilk-5 multithreaded language}},
url = {http://dl.acm.org/citation.cfm?id=277652.277725},
volume = {33},
year = {1998}
}
@article{Leiserson2010,
abstract = {The availability of multicore processors across a wide range of computing platforms has created a strong demand for software frameworks that can harness these resources. This paper overviews the Cilk++ programming environment, which incorporates a compiler, a runtime system, and a race-detection tool. The Cilk++ runtime system guarantees to load-balance computations effectively. To cope with legacy codes containing global variables, Cilk++ provides a ldquohyperobjectrdquo library which allows races on nonlocal variables to be mitigated without lock contention or substantial code restructuring.},
author = {Leiserson, Charles E.},
doi = {10.1007/s11227-010-0405-3},
file = {:home/etn/Documents/PhD/Biblio/Leiserson - 2010 - The Cilk concurrency platform.pdf:pdf},
isbn = {978-1-6055-8497-3},
issn = {09208542},
journal = {Journal of Supercomputing},
keywords = {Amdahl's Law,Dag model,Hyperobject,Multicore programming,Multithreading,Parallel programming,Parallelism,Race detection,Reducer,Span,Speedup,Work},
month = {mar},
number = {3},
pages = {244--257},
title = {{The Cilk++ concurrency platform}},
url = {http://link.springer.com/10.1007/s11227-010-0405-3},
volume = {51},
year = {2010}
}
@article{Li2007,
abstract = {This paper proposes to combine two seemingly opposed programming models for building massively concurrent network services: the event-driven model and the multithreaded model. The result is a hybrid design that offers the best of both worlds-the ease of use and expressiveness of threads and the flexibility and performance of events. This paper shows how the hybrid model can be implemented entirely at the application level using concurrency monads in Haskell, which provides type-safe abstractions for both events and threads. This approach simplifies the development of massively concurrent software in a way that scales to real-world network services. The Haskell implementation supports exceptions, symmetrical multiprocessing, software transactional memory, asynchronous I/O mechanisms and application-level network protocol stacks. Experimental results demonstrate that this monad-based approach has good performance: the threads are extremely lightweight (scaling to ten million threads), and the I/O performance compares favorably to that of Linux NPTL. tens of thousands of simultaneous, mostly-idle client connections. Such massively-concurrent programs are difficult to implement, especially when other requirements, such as high performance and strong security, must also be met.},
author = {Li, Peng and Zdancewic, Steve},
doi = {10.1145/1273442.1250756},
file = {:home/etn/Documents/PhD/Biblio/Li, Zdancewic - 2007 - Combining events and threads for scalable network services implementation and evaluation of monadic, application-.pdf:pdf},
isbn = {9781595936332},
issn = {03621340},
journal = {ACM SIGPLAN Notices},
keywords = {concurrency,event,haskell,implementation,monad,networking,programming,scalability,thread},
month = {jun},
number = {6},
pages = {189},
publisher = {ACM},
title = {{Combining events and threads for scalable network services implementation and evaluation of monadic, application-level concurrency primitives}},
url = {http://dl.acm.org/citation.cfm?id=1273442.1250756 http://dl.acm.org/citation.cfm?id=1250756},
volume = {42},
year = {2007}
}
@article{Dabek2002,
abstract = {Events are a better means of managing I/O concurrency in server software than threads: events help avoid bugs caused by the unnecessary CPU concurrency introduced by threads. Event-based programs also tend to have more sta- ble performance under heavy load than threaded programs. We argue that our libasync non-blocking I/O library makes event-based programming convenient and evaluate exten- sions to the library that allow event-based programs to take advantage of multi-processors. We conclude that events pro- vide all the benefits of threads, with substantially less com- plexity; the result is more robust software.},
address = {New York, New York, USA},
author = {Dabek, Frank and Zeldovich, Nickolai},
doi = {10.1145/1133373.1133410},
file = {:home/etn/Documents/PhD/Biblio/Dabek, Zeldovich - 2002 - Event-driven programming for robust software.pdf:pdf},
journal = {Proceedings of the 10th workshop on ACM SIGOPS European workshopn workshop},
month = {jul},
pages = {186 -- 189},
publisher = {ACM Press},
title = {{Event-driven programming for robust software}},
url = {http://dl.acm.org/citation.cfm?id=1133373.1133410 http://dl.acm.org/citation.cfm?id=1133410},
year = {2002}
}
@article{Haller2007,
abstract = {There is an impedance mismatch between message-passing concurrency and virtual machines, such as the JVM. VMs usually map their threads to heavyweight OS processes. Without a lightweight process abstraction, users are often forced to write parts of concurrent applications in an event-driven style which obscures control flow, and increases the burden on the programmer. In this paper we show how thread-based and event-based programming can be unified under a single actor abstraction. Using advanced abstraction mechanisms of the Scala programming language, we implemented our approach on unmodified JVMs. Our programming model integrates well with the threading model of the underlying VM.},
author = {Haller, Philipp and Odersky, Martin},
doi = {10.1007/978-3-540-72794-1{\_}10},
file = {:home/etn/Documents/PhD/Biblio/Haller, Odersky - 2007 - Actors That Unify Threads and Events.pdf:pdf},
isbn = {978-3-540-72793-4},
issn = {03029743},
journal = {Coordination 2007, Lncs 4467},
pages = {171--190},
title = {{Actors That Unify Threads and Events}},
url = {http://lamp.epfl.ch/{~}phaller/doc/haller07coord.pdf},
year = {2007}
}
