Automatically generated by Mendeley Desktop 1.16-dev4
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@book{Liskov1988,
author = {Liskov, B and Shrira, L},
title = {{Promises: linguistic support for efficient asynchronous procedure calls in distributed systems}},
url = {http://dl.acm.org/citation.cfm?id=54016},
year = {1988}
}
@article{Felleisen1991,
author = {Felleisen, M},
file = {:home/etn/Documents/PhD/Biblio/Bhatotia et al. - 2011 - Incoop MapReduce for incremental computations.pdf:pdf},
journal = {Science of computer programming},
title = {{On the expressive power of programming languages}},
url = {http://www.sciencedirect.com/science/article/pii/016764239190036W},
year = {1991}
}
@article{Parnas2002,
author = {Parnas, DL},
journal = {Software pioneers},
title = {{The secret history of information hiding}},
url = {http://link.springer.com/chapter/10.1007/978-3-642-59412-0{\_}26},
year = {2002}
}
@article{Parnas1972,
abstract = {This paper discusses modularization as a mechanism for improving the flexibility and comprehensibility of a system while allowing the shortening of its development time. The effectiveness of a $\backslash$"modularization $\backslash$" is dependent upon the criteria used in dividing the system into modules. A system design problem is presented and both a conventional and unconventional decomposition are described. It is shown that the unconventional decompositions have distinct advantages for the goals outlined. The criteria used in arriving at the decom-positions are discussed. The unconventional decomposi-tion, if implemented with the conventional assumption that a module consists of one or more subroutines, will be less efficient in most cases. An alternative approach to implementation which does not have this effect is sketched.},
author = {Parnas, D. L.},
doi = {10.1145/361598.361623},
file = {:home/etn/Documents/PhD/Biblio/Parnas - 1972 - On the criteria to be used in decomposing systems into modules.pdf:pdf},
isbn = {0917072146},
issn = {00010782},
journal = {Communications of the ACM},
keywords = {KWIC index,modularity,modules,software,software design,software engineering},
number = {12},
pages = {1053--1058},
pmid = {213},
title = {{On the criteria to be used in decomposing systems into modules}},
url = {http://dl.acm.org/citation.cfm?id=361623 http://portal.acm.org/citation.cfm?doid=361598.361623},
volume = {15},
year = {1972}
}
@inproceedings{Wong2009,
author = {Wong, Sunny and Cai, Yuanfang and Valetto, Giuseppe and Simeonov, Georgi and Sethi, Kanwarpreet},
booktitle = {2009 IEEE/ACM International Conference on Automated Software Engineering},
doi = {10.1109/ASE.2009.53},
file = {:home/etn/Documents/PhD/Biblio/Wong et al. - 2009 - Design Rule Hierarchies and Parallelism in Software Development Tasks.pdf:pdf},
isbn = {978-1-4244-5259-0},
keywords = {collaboration,project management,software architecture},
month = {nov},
pages = {197--208},
publisher = {IEEE},
title = {{Design Rule Hierarchies and Parallelism in Software Development Tasks}},
url = {http://dl.acm.org/citation.cfm?id=1747491.1747520},
year = {2009}
}
@article{Odersky2004,
abstract = {Scala fuses object-oriented and functional programmin gin a statically typed programming language. It is aimed at teh construction of componetns and component systems. This paper gives an overview of teh Scala language for readers who are familiar with programming methods and programming language design.},
author = {Odersky, Martin and Altherr, Philippe and Cremet, Vincent and Emir, Burak and Maneth, Sebastian and Micheloud, St{\'{e}}phane and Mihaylov, Nikolay and Schinz, Michel and Stenman, Erik and Zenger, Matthias},
file = {:home/etn/Documents/PhD/Biblio/Odersky et al. - 2004 - An Overview of the Scala Programming Language.pdf:pdf},
isbn = {0849331358},
journal = {System},
number = {Section 2},
pages = {1--130},
title = {{An Overview of the Scala Programming Language}},
url = {http://infoscience.epfl.ch/record/52656/files/ScalaOverview.pdf http://infoscience.epfl.ch/record/52656/files/ScalaOverview.pdf?version=1},
year = {2004}
}
@book{Goldberg1984,
abstract = {The book is divided into five parts. Part One introduces the usr interface to the Smalltalk-80 syste, Part Two is an explanation of the support provided for finding information about objects that exist in the Smalltalk-80 sytem. Part Three provides an illustrated descrption of how to explore the class descriptions available in the system, and of how to use the editors for implementing new class descriptions. Part Four presents the support available for finding and correcting errors, while Part Five introduces acess to external files and such system housekeeping support as crash recovery and change management. The book is written to encourage specific practice and exploration. A brief introduction to the Smalltalk-80 language is also provided in order to explain the ways in which the user interface components provide access to the language components. For a more in-depth understanding of the language, reader may use this book in conjunction with Smalltalk-80: The Language and Its Implementation, by Adele Goldberg and David Robson (Addison-Wesley, 1983), which includes reference material for the system classes.},
author = {Goldberg, Adele},
booktitle = {Addison-Wesley series in computer science},
isbn = {0201113724},
keywords = {Smalltalk-80 (Computer program language)},
pages = {xi, 516 p.},
pmid = {3295996},
title = {{Smalltalk-80 : the interactive programming environment}},
url = {http://cumincad.scix.net/cgi-bin/works/Show?61be},
year = {1984}
}
@book{Gosling2000,
author = {Gosling, J},
title = {{The Java language specification}},
url = {https://books.google.com/books?hl=en{\&}lr={\&}id=Ww1B9O{\_}yVGsC{\&}oi=fnd{\&}pg=PA1{\&}dq=Java{\&}ots=Sf2HglQaiE{\&}sig=I{\_}w6xyrKO4thAA7rHx{\_}ZArjkJf0},
year = {2000}
}
@article{Stroustrup1986,
author = {Stroustrup, B},
title = {{The C++ programming language}},
url = {https://scholar.google.com/scholar?q=C{\%}2B{\%}2B{\&}btnG=Search{\&}as{\_}sdt=800000000001{\&}as{\_}sdtp=on{\#}0},
year = {1986}
}
@article{Ecma1999,
author = {Ecma, ECMA},
journal = {ECMA (European Association for Standardizing Information and Communication Systems), pub-ECMA: adr,},
title = {{262: ECMAScript Language Specification}},
url = {https://scholar.google.com/scholar?q=ECMAscript language specification{\&}btnG=Search{\&}as{\_}sdt=800000000001{\&}as{\_}sdtp=on{\#}0},
year = {1999}
}
@book{Armstrong2014,
abstract = {Erlang solves one of the most pressing problems facing developers today: how to write reliable, concurrent, high-performance systems. It's used worldwide by companies who need to produce reliable, efficient, and scalable applications. Invest in learning Erlang now. Moore's Law is the observation that the amount you can do on a single chip doubles every two years. But Moore's Law is taking a detour. Rather than producing faster and faster processors, companies such as Intel and AMD are producing multi-core devices: single chips containing two, four, or more processors. If your programs aren't concurrent, they'll only run on a single processor at a time. Your users will think that your code is slow. Erlang is a programming language designed for building highly parallel, distributed, fault-tolerant systems. It has been used commercially for many years to build massive fault-tolerated systems that run for years with minimal failures. Erlang programs run seamlessly on multi-core computers: this means your Erlang program should run a lot faster on a 4 core processor than on a single core processor, all without you having to change a line of code. Erlang combines ideas from the world of functional programming with techniques for building fault-tolerant systems to make a powerful language for building the massively parallel, networked applications of the future. This book presents Erlang and functional programming in the familiar Pragmatic style. And it's written by Joe Armstrong, one of the creators of Erlang. It includes example code you'll be able to build upon. In addition, the book contains the full source code for two interesting applications: - A SHOUTcast server which you can use to stream music to every computer in your house, and - a full-text indexing and search engine that can index gigabytes of data. Learn how to write programs that run on dozens or even hundreds of local and remote processors. See how to write robust applications that run even in the face of network and hardware failure, using the Erlang programming language.},
author = {Armstrong, Joe},
booktitle = {North},
doi = {10.1017/S0956796809007163},
isbn = {9781934356005},
issn = {09567968},
pages = {519},
publisher = {Pragmatic Programmers},
title = {{Programming Erlang}},
url = {http://cds.cern.ch/record/1970203},
year = {2007}
}
@article{Sackman1968,
abstract = {Two exploratory experiments were conducted at System Development Corporation to compare debugging performonce of programmers working under conditions of online and offline access to a computer. These are the first known studies that measure programmers' performance under controlled conditions for standard tasks. Statistically significant results of both experiments indicated faster debugging under online conditions, but perhaps the most important practical finding involves the striking individual differences tn programmer performance. Methodological problems encountered in designing and conducting these experiments are described; limitations of the findings are pointed out; hypotheses are presented to account for results; and suggestions ore made for further research.},
author = {Sackman, H. and Erikson, W. J. and Grant, E. E.},
doi = {10.1145/362851.362858},
file = {:home/etn/Documents/PhD/Biblio/Sackman, Erikson, Grant - 1968 - Exploratory Experimental Studies Comparing Online and Offline Programming Performance.pdf:pdf},
isbn = {0-8186-0751-3},
issn = {0001-0782},
journal = {Communi},
keywords = {and phrases,botch processing,computer communication,debugging,effectiveness,empirical studies,factor analysis application,offline performance,online vs,programmer,programming cost effectiveness 1,programming experimental,progromming performance,time sharing vs},
number = {1},
pages = {3--11},
title = {{Exploratory Experimental Studies Comparing Online and Offline Programming Performance}},
volume = {11},
year = {1968}
}
