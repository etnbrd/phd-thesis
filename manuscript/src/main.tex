\documentclass[12pt]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[french, english]{babel}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{svg}

\usepackage{tikz}
\usepackage{pgfplots}
\usepgfplotslibrary{external} 
\tikzexternalize
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=0.8pt] (char) {#1};}}


\usepackage[hyperref=true,%
            url=false,%
            isbn=false,%
            style=numeric,%
            maxcitenames=3,%
            maxbibnames=100,%
            block=none]{biblatex}

\bibliography{../src/bib/OS.bib}
\bibliography{../src/bib/Flow-Based Programming.bib}
\bibliography{../src/bib/Functional Programming-Functional Reactive Programming.bib}
\bibliography{../src/bib/Stream.bib}
\bibliography{../src/bib/Dataflow.bib}
\bibliography{../src/bib/Web & Social Networks.bib}
\bibliography{../src/bib/Others.bib}
\bibliography{../src/bib/Actor Model.bib}
\bibliography{../src/bib/Misc.bib}
\bibliography{../src/bib/Parallelisation.bib}
\bibliography{../src/bib/Others.bib}
\bibliography{../src/bib/Distributed Systems.bib}
\bibliography{../src/bib/sigproc.bib}

\input{utils/code}
\input{utils/macros}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\begin{document}

%\title{Operating Systems mutations, how and why integrate the user in the digital era ?\\\comment{TODO change title ?}}
% \title{Automatic pipeline distribution for monolithic web applications : Toward a better compromise between development scalability and performance scalability \comment{not definitive}}
\title{Liquid IT : Toward a better compromise between development scalability and performance scalability \comment{not definitive}}
\author{Etienne Brodu}

\maketitle

\input{00-abstract/main}

\tableofcontents

\input{01-introduction/main}
% \input{02-context/main}

\chapter{Context \& Objectives}
  \section{The Web as a platform}

    \subsection{From OS to Web platform}

      The focus of the software industry switched from native desktop applications to mobile and web applications.
      In this 

    \subsection{The languages of the web}

      Javascript(1995), Ruby(1993), PHP(1995) and Java(1994) were all created around the same time, in 1995.
      Java imposes itself early as the language of the web, and never really decreased. It is a solid, professional language used by most of the industry.
      But it is too big, and too slow growing for the exact same reason.

      Python is older (1991), and was always seen as a general purpose language.
      It is only in 2003, with the Django framworks that Python start to be seen as a web language.

      PHP short-lived as the easy-to-use scripting language, it is now backed by facebook, but is on the decline.

      Ruby took-off in 2005 with Rails, and is still in active use.
      But it seems it is going to be eclipsed by Javascript.

      Since a few years, Javascript is in a constant rise as the main language of the web, because of Ajax first, and then Node.js
      What is so different with Javascript ?
      It is omnipresent, from every browser, to the server.
      And it is a target for LLVM.
      Because of this position, it became fast (V8, ASM.js ...) and usable (ES6, ES7).

    \subsection{Explosion of Javascript popularity}
      % \subsubsection{In the beginning}
      % \subsubsection{Rising of the unpopular language}
      % \subsubsection{Current situation}
      % \subsubsection{Success stories}
   
      (I already have a few pages written on this)
      The history of Javascript, from 1995 to now.
      With numbers about the popularity of Javascript on Github, StackOverflow and different indexes.

      With numbers from Worldline about Java and Javascript usages.

      It ends with some success stories with Javascript (Paypal, Linkedin and so on ...).

      -> There is a growing mass of developers for Javascript.
      And even for those who don't program in Javascript, there is transpilers.
      Javascript is here to stay : http://www.javaworld.com/article/2077224/learn-java/is-javascript-here-to-stay-.html (an article from 1996, where Java was still the hot new language)

  \section{The pivot \comment{Problem}}

    But many large company replaced the initial languages of the web with scalable solutions.
    Twitter : Ruby -> Storm
    Facebook : PHP -> HHVM / Flux ...
    Google : MapReduce, Kubernetes, Borg ...

    \subsection{Development \& Performance Scalability}

    I explain exactly what I mean by Development scalability (I should change the term, it is misleading and not explicit enough), and Performance scalability.

    \subsection{A difficult compromise}

    I explain why the two are difficult to merge together.
    It is difficult to design a language for parallel programming which is simple enough, and scalable enough.
    Either it is scalable, or it has wide adoption (because it is simple enough)

  \section{Proposal and Hypothesis}

    \subsection{\comment{Hypothesis}}

    \comment{The hypothesis : It is hard for developers to assure the invariant on the memory. Most use synchronization, and fail, a very few use isolation (parallel languages), and between the two, there is the event-loop : turn-based programming which is an alternative to synchronization and isolation.}

    \subsection{LiquidIT}

    A general definition of Liquid IT.
    And more specifically the focus on dev and perf scalability.
    Liquid IT should try to bring a solution to this compromise leveraging the particular position of Javascript and its event-loop.


    \subsection{Parallelization and distribution of web applications}
    % \subsection{Pipeline parallelism for event-loop}

    \comment{The thesis : with the help from a compiler, it is possible to automatically transform this class of application : flow applications, into independent components (like difficult parallel languages)}

    \comment{The article your server as a function is similar to storm (except in C, apparently).
    It is a very good solution for a specific class of applications : stateless applications.
    For stateful applications, it relies on a database, like Storm.
    But a database is too much : if a stateless application is the best case for scalability, a database is the worst case.
    Some applications are in the middle, they don't need a database, but they are not stateless : flow application -> state without retro-propagation}


% \input{03-proposition/main}

%\chapter{A framework for parallel web applications}
 % \section{Fluxions}

\chapter{\comment{State of the art}}

  \section{Javascript}
    \subsection{Overview of the language}
      \subsubsection{Functions as First-Class citizens}
      \subsubsection{Lexical Scoping}
      \subsubsection{Closure}

  \section{Concurrency}
    \subsection{Two known concurrency model}
      \subsubsection{Thread}
      \subsubsection{Event}
      \subsubsection{Orthogonal concepts}
    \subsection{Differentiating characteristics}
      \subsubsection{Scheduling}
      \subsubsection{Coordination strategy}
    \subsection{Turn-based programming}
      \subsubsection{Event-loop}
      \subsubsection{Promises}
      \subsubsection{Generators}
    \subsection{\comment{Message-passing / pipeline parallelism -> DataFlow programming ?}}

  \section{Scalability}
    \subsection{Theories}
      \subsubsection{Linear Scalability}
      \subsubsection{Limited Scalability}
      \subsubsection{Negative Scalability}
        \comment{Conclusion : scalability = concurrency + not sharing the resources that grows with the scale}
    \subsection{Scalability outside computer science (only if I have time)}
        \comment{
          If I have time, I would like to try to explain why scalability is at the core of material engagement and information theory,
          and is at the core of our universe : the propagation of Gravity wave is an example : it is impossible to scale
          }

  \section{Framworks for web application distribution}
    \subsection{Micro-batch processing}
    \subsection{Stream Processing}
  
  \section{Flow programming}
      \subsection{Functional reactive programming}
      \subsection{Flow-Based programming}
  \section{Parallelizing compilers}
    \comment{OpenMP and so on}
    %\subsubsection{\comment{TODO}}

  \section{\comment{Synthesis}}
    \comment{There is no compiler focusing on event-loop based applications}

\chapter{Fluxion}

  \section{Fluxionnal Compiler}
    \comment{Some parts of this are already written in the first paper. It needs a lot additional explanations and rewritting}
    \subsection{Identification}
      \subsubsection{Continuation and listeners}
      \subsubsection{Dues}
    \subsection{Isolation}
      \subsubsection{Scope identification}
        \comment{Scope leaking}
      \subsubsection{Execution and variable propagation}
    \subsection{distribution}

  \section{Fluxionnal execution model}
    \comment{Everything here is already written in the first paper  : flx-paper. It only needs to be rewritten}
    \subsection{Fluxion encapsulation}
      \subsubsection{Execution}
      \subsubsection{Name}
      \subsubsection{Memory}
    \subsection{Messaging system}

\chapter{Evaluation}
  \section{Due compiler}
  \section{Fluxionnal compiler}
  \section{Fluxionnal execution model}

\input{90-conclusion/main}
\input{91-appendix/main}

\printbibliography[]

\end{document}