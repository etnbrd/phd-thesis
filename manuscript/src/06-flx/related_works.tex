\section{Related Works} \label{section:related}

Splitting a task into independent parts goes back to the Actor's model, functional programming \cite{Hughes1989} and the following works on Data\-Flow leading to Flow-based Programming (FBP) and Functional Reactive program\-ming (FRP) \cite{Elliott1997}.
Both FBP and FRP, recently got some attention in the Javascript community with \textit{NoFlo}\ftnt{http://noflojs.org/}, \textit{Bacon.js}\ftnt{https://baconjs.github.io/} and \textit{react}\ftnt{https://facebook.github.io/react/}.

The execution model we presented in section \ref{section:model}, is inspired by works on scalability for very large systems, like the Staged Event-Driven Architecture (SEDA) by Matt Welsh \cite{Welsh2000} and by the MapReduce architecture \cite{Dean2008}.
It also drew its inspiration from more recent work following SEDA like Spark \cite{Zaharia2012}, MillWheel \cite{Akidau2013}, Naiad \cite{McSherry} and Storm \cite{Toshniwal2014}.
The first part of our work stands upon these thorough studies.
However, we believe that it is difficult for most developers to distribute the state of an application.
This belief motivated us to propose a compiler from an imperative programming model to these more scalable, distributed execution engines.

The transformation of an imperative programming model to be executed onto a parallel execution engine was recently addressed by Fernandez \textit{et. al.} \cite{Fernandez2014a}.
However, as in similar works \cite{Power2010}, it requires annotations from developers, therefore partially conserves the disruption with the feature-based development.
Our approach discards the need for annotations, thus targets a broader range of developers than only ones experienced with parallel development.

A great body of work focuses on parallelizing sequential programs \cite{Banerjee2013,Li2012,Matsakis2012a,Radoi2014}.
Because of the synchronous execution of a sequential program, the speedup of parallelization is inherently limited \cite{Amdahl1967,Gunther2008}.
On the other hand, our approach is based on an asynchronous programming model.
Hence the attainable speedup is not limited by the main synchronous thread of execution.