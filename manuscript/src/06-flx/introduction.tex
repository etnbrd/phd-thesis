\section{Introduction}

\textit{``Release early, release often''}, \textit{``Fail fast''}.
The growth of a real-time web service is partially due to Internet's capacity to allow very quick releases of a minimal viable product (MVP).
It is crucial for the prosperity of such project to quickly validate that it meets the needs of its users.
Indeed, misidentifying the market needs is the first reason for startup failure\ftnt{https://www.cbinsights.com/blog/startup-failure-post-mortem/}.
Hence the development team quickly concretizes an MVP using a feature-driven approach and iterates on it.

The service needs to be scalable to be able to respond to the growth of its user-base.
However, feature-driven development best practices are hardly compatible with the required parallelism.
The features are organized in modules which disturb the organization of a parallel execution \cite{Clements2013a,Hughes1989,Parnas1972}.
Eventually the growth requires to discard the initial approach to adopt a more efficient processing model.
Many of the most efficient models decompose applications into execution units \cite{Fox1997, Welsh2000, Dean2008}.
However, these tools are in disruption from the initial approach.
This shift causes the development team to spend development resources in background to start over the initial code base, without adding visible value for the users.
It is a risk for the evolution of the project.
Running out of cash and missing the right competences are the second and third reasons for startup failures$^2$.

The risk described above comes from a disruption between the two levels of application expression, the feature level and the execution level.
To avoid this risk and allow a continuous development process, we propose a tool to automatically map one level onto the other, and make the transition.

We focus on web applications driven by users requests and developed in Javascript using the \textit{Node.js}\ftnt{https://nodejs.org/} execution environment.
Javascript is widely adopted\ftnt{http://githut.info/}\ftnt{http://stackoverflow.com/tags} to develop web applications, and its event-loop model is very similar to a pipeline architecture.
So we propose a compiler to transform an application into a pipeline of parallel stages communicating by message streams.
We named these stages \textit{fluxions}, by contraction between a flux and a function.

We present a proof of concept for this compilation approach.
Section \ref{section:model} describes the execution environment targeted by this compiler.
Then, section \ref{section:compiler} presents the compiler, and section \ref{section:evaluation} its evaluation.
Section \ref{section:related} compare our work with related works.
And finally, we conclude this paper.