\section{An Economical Problem} \label{chapter2:problem-statement}

With SaaS, the software industry is in charge of both development and execution of the software.
The previous section presented these two aspects individually.
This section presents the challenges encountered by conducting the two at world wide scale.
It then focuses on the subject and defines the objectives of this thesis.

\subsection{Disrupted Web Development}

% The Web allows a project to grow quickly from a very early stage to a large business.
The economical constraints to meet are very different in the beginning and during the maturation of a web application.
In the early steps the constraints hold on the development productivity.
The team needs to reduce development costs, and to release a first version as soon as possible.
On the contrary, during the maturation of the application, the constraints hold on the performance efficiency.
The application needs to be highly concurrent to meet the load of usage.

The team need to revise its approach to meet these different constraints.
These revisions leads to disruptions in the evolution of the application.
% This section further details the reasons and consequences of these disruptions.

\subsubsection{Power-Wall Disruption}

\illustration{heating chipset / parallel chipsets}

Around 2004, manufacturers reached what they called the \textit{Power-wall}.
The speed of sequential execution on a processing unit plateaued\ftnt{https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/}.
Therefore, the performance of sequential programming plateaued as well.
They started to arrange transistors into several processing units to keep increasing overall performance efficiency. % while avoiding overheating problems.
% required by the cooperative scheduling 
Parallel programming became the only option to achieve high concurrency, but the memory isolation it requires limits the productivity.
% Isolating tasks is the only option to achieve high concurrency on this parallel hardware.
% These best-practices are presented in further details in section \ref{chapter3:software-maintainability}
This \textit{Power-wall} leads to a rupture between efficiency and productivity.

\subsubsection{Unavoidable Modularity}

The best practices for productivity in software development advocate to gather features logically into distinct modules.
This modularity allows a developer to understand and contribute to an application one module at a time, instead of understanding the whole application.
It allows to develop and maintain a large code-base by a multitude of developers bringing small, independent contributions.

This modularity avoids a different problem than the isolation required by parallelism.
The former intends to structure code to improve maintainability, while the latter improve performance through parallel execution.
These two organizations are conflicting in the design of the application.
The next paragraph presents the disruptions in the development of a web application implied by this conflict.

\subsubsection{Technological Shift}

% Between the prototyping, and the maturation of a web application, the needs are radically different.
% During the initiation of a web application project, the economical constraint holds on the development productivity.
% The development reactivity is crucial to meet the market needs\ftnt{https://www.cbinsights.com/blog/startup-failure-post-mortem/}.
The development team opt for a popular and accessible language to be productive in the beginning of the project. %  leverage the advantage of its community.
It is only after a certain threshold of user load that the economical constraint on efficiency exceeds the one on productivity.
The development team then shifts to an organization providing parallelism.

This shift brings two risks.
The development team needs to rewrite the code base to adapt it to a completely different paradigm.
The application risks to fail because of this challenge.
And after this shift, the development pace slows down.
The development team cannot react as quickly to user feedbacks to adapt the application to the market needs.
The application risks to fall in obsolescence.

The risks implied by this rupture proves that there is economically a need for a solution that continuously follows the evolution of a web application.
The proposition of this thesis is presented in the next section.
The proposed solution would allow developers to iterate continuously on the implementation focusing simultaneously on performance, and on maintainability.

\subsection{Seamless Web Development}

This thesis is conducted in the frame of a larger work on LiquidIT within the Worldline company.
Worldline develops and hosts real-time streaming Web services, and identified that one of their need was to increase the time to market for its products.
Worldline defines LiquidIT as \textit{a concept of flexible and cost-effective IT services that can be provisioned, built and configured in real time, allowing end-to-end financial transparency}.
It precisely intends to provide \textit{business agility, investment-free charging models, flexibility and ease of use}.
This thesis intends to allow the developer to focus solely on business logic, and leave the technical constraints of performance scalability to automated tools.
The objective of this work are avoid the disruption in development, and provide a seamless development experience.
They are presented in the next paragraphs.

\subsubsection{Real-Time Streaming Web Services}

This thesis focuses on web applications processing streams of requests from users in soft real-time.
Such applications receive requests from clients through the HTTP protocol and must respond within a finite window of time.
They are generally organized as sequences of tasks to modify the input stream of requests to produce the output stream of responses.
The stream of requests flows through the tasks, and is not stored.
On the other hand, the state of the application remains in memory to impact the future behaviors of the application.
This state might be shared by several tasks within the application, and imply coordination between them.

As presented in the previous section, such applications are often implemented with the event-driven programming model or the pipeline programming model.
Despite the differences between the two models, an equivalence to map these differences is developed throughout this thesis.
% The next section introduces the differences between these two programming models and outlines an equivalence to map these differences.

\subsubsection{Differences}

Both programmng models encapsulate the execution in tasks assured to have an exclusive access to the memory.
However, they use two different models to provide this exclusivity.
Contrary to the pipeline architecture, the event-loop provides a common memory store allowing the best practice of software development to improve maintainability.

However, these two organizations are incompatible.
Because of economical constraints, this incompatibility implies ruptures in the development.
It represents additional development efforts and important costs.
This thesis argues that it is possible to allow a continuous development between the two organizations, so as to lift these efforts and costs.
The argumentation of this possibility is based on an equivalence bridging the two organizations.
This equivalence is presented briefly in the next paragraph, and detailed further in the chapter \ref{chapter4} and \ref{chapter5}.

\subsubsection{Equivalence}

In the beginning of a project, the team adopts the event-driven execution model to focus on maintainability and evolution, discarding the scalable performance concerns.
And as the project gather audience and the performance concerns become more and more critical, the development team adopt the pipeline execution model to take into account this performance concerns.
The equivalence would allow a compiler to transform an application expressed in one model into the other.

With this equivalence, it would be possible to express an application following the design principles of software development.
A development team could rely on the common memory store of the event-driven execution model, and focuses on the maintainability of the implementation.
And yet, because of the equivalence between these two models, the execution engine could adapt itself to any parallelism of the computing machine, from a single core, to a distributed cluster.
The development team could continuously progress with the two models and take advantage of their different concerns about the implementation, performance and maintainability.

\separator

This thesis proposes to provide an equivalence between the two memory models for streaming web applications.
The goal of conciliating these two concerns is not new.
The next chapter presents all the previous results needed to understand this work, up to the latest advances in the field.