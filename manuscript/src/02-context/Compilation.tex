\section{Equivalence}





I argue that the language should propose to the developer an abstraction to encourage the best practices of software development.
Then a compiler, or the execution engine, can adapt this abstraction so as to leverage parallel architectures. 
So as to provide to the developer a usable, yet efficient compromise.
We propose to find an equivalence between the invariance proposed by the cooperative scheduling paradigm and the invariance proposed by the multi-processes paradigm, to be applied between the event-loop execution engine and the pipline architecture.


\nt{Define event-loop and pipeline architecture, from cooperative scheduling and multi-process, and then continue with the equivalence}


\subsection{Architecture}


\subsubsection{Event-loop}

\subsubsection{PIpeline}


\subsubsection{Rupture point}




\subsection{Real-time web services}

\nt{The need for invariance in the streaming applications : it can be emulated by message passing. Indeed the data flows from one processing step to the other, with few retroprogation of state (don't mention retro-propagation yet)}

This equivalence intend not to be universal.
It focuses on a precise class of applications : real-time Web applications processing stream of requests from users.
Web applications are now written in a stream fashion.
Indeed, as I showed previously, the event loop is executed like a pipeline.
Web services can be seen as pipelines processing streams of requests.

In a stream processing application, there is roughly two kinds of usage of the global memory : data and state.
Naively, the data represent a communication channel between different point in the application space, and the state represents a communication channel between different instant in time.
The data flow from stage to stage through the pipeline, and are never stored on any parts.
The state, on the other hand, remains in the memory to impact the future behaviors of the application.
State might be shared by several parts of the application.

There are different kinds of state dependencies in applications components leading to different kinds of parallelism.
In this thesis I argue that it is possible to parallelize a real-time web applications written on an event-loop because the strong dependencies mainly remains within a closed number of concurrent executions.

\subsection{Transformation}

The equivalence between the invariance of the event-loop paradigm and the invariance of the multi-process paradigm involves two steps.
The first step is to isolate the different regions 


Second the coordination of these regions by message-passing.








This equivalence should allow a compiler to transform an event loop into several parallel processes communicating by messages.

With this compiler, it would be possible to express an application with a global, so as to follow the design principles of software development.
And yet, the execution engine could adapt itself to any parallelism of the computing machine, from a single core, to a distributed cluster.







\nt{TODO I whould talk about the event-loop, rupture points, and the invariance. Continue this.}



\endinput


We translate the definition of the invariance in time by an invariance in space.



\subsubsection{Event-loop and multi-processes paradigms}

\nt{TODO merge this section with time-slicing and parallelism}

We draw the similarity and differences between the event-loop and multi-processes paradigms.

The event-loop paradigm split the execution of a program into sequentially executed callbacks.
% Each event triggers the execution of a callback.
% This callback can at its turn send events to triggers callbacks.
It uses the cooperative scheduling strategy so that each callback as an exclusive access to the global memory storing the state of the application.
All the tasks, called events, are executed sequentially, so there is no possible simultaneous memory access.
For this reason, it imposes the application to be executed on a single processing unit.
In application using cooperative scheduling on an event-loop, like Javascript, the memory is global.

An application following the multi-processes paradigm splits the execution of a program into parallel processes.
Each process has an exclusive access to its own memory to store a fraction of the state of the application.
The developer is aware that only the process can modify its memory.
It uses message-passing to coordinate the state of the application at the global level, and to stream data from one process to the other.
Each process treat these messages one after the other.

Both paradigms encapsulate the execution, in callbacks or processes.
Those containers are assured to have an exclusive access to the memory.
The difference between these paradigms lies in the choice of exclusivity for the access to the state, and in the coordination of the state between the concurrent executions.

% I focus on a solution to leverage parallelism while keeping the global memory for developers.
I focus on the coordination of state between the concurrent executions in concurrent programming.
% I presented earlier the three main strategies to manage the memory in concurrent programming.
The main difference for the developer is how each paradigm assures to the developer the invariance in the memory state.

\nt{TODO it is not universal, but multi-process paradigms are also oriented around event-loops. An Event-loop is a multi-process on one machine. A multi-process is multiple event-loop running different part of the same program.}
