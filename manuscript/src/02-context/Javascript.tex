\section{Javascript}

\subsection{Explosion of Javascript popularity}

\subsubsection{In the beginning}

Javascript was created by Brendan Eich in 10 days in May 1995, while he was working at Netscape.
The inital name of the project was Mocha, and then switched to LiveScript when released to the public in September 1995.
The name Javascript was later adopter to leverage the trend around Java.
Indeed, Java was considered the new hot web programming language at this time.
% TODO read Javascript the good parts

Microsoft released a concurrent implementation of Javascript in June 1996 in their browser Internet Explorer 3.
They changed the name to JScript, to avoid trademark conflict with Oracle Corporation, who owns the name Javascript.
But the differences between the two implementations made difficult for a script to be compatible for both.
Netscape submitted Javascript to Ecma International for standardization in November 1996.
In June 1997, Ecma International released ECMA-262, the first specification of EcmaScript, the standard for Javascript.
% TODO more on the Ecma specification please

It was designed as a simple language to attract unexperienced developers.
By opposition to Java or C++, which target professional developers.
% TODO reformulate that

\subsubsection{Rising of the unpopular language}

Javascript started as a programming language to animate web pages.
It was used as a script language to implement short interactions.
The main usage was for validate form on the client, avoiding unnecessary calls to the server.

In 2005 James Jesse Garrett released Ajax: A New Approach to Web Applications, a white paper coining the term Ajax. \cite{Garrett2005}
Ajax, consists in using Javascript to dynamically request and refresh the content of a web page.
This paper point the trend in using this technique, and explain the consequences on user experience.
Indeed, an application able to react to the user without completely refreshing the page, is bringing the web closer to a native application.
At the time, some important web application started using this technique.
The most important being Gmail, the google mail client.

At roughly the same time famous Javascript libraries were released with the goal to fill the differences between browsers implementations of Javascript.

% TODO there is probably a lot more to write about this transition :
% - Google used a lot of Ajax in its sites (gmail, google maps, orkut and so on ...)
% - jquery / prototype ... all the famous library that helped Javascript gain in popularity
% - ... ?

\subsubsection{Current situation : complete world domination}

All modern web browsers now include a Javascript interpreter, making Javascript the most ubiquitous runtime in history. \cite{Flanagan2006}

But the fact that Javascript is the language of the web, also made it famous in the open source communities.
Javascript is the language counting the most repository on github, and is the most tagged language in StackOverflow.

Languages like Java and C/C++ are in active use in the software industry.
Javascript on the other hand, is rising from the open source community and is slowly taking over the software industry as well.

With the release of HTML5, the importance of Javascript was completely acknowledged.
It marked the consideration of the web as viable alternative for desktop clients.
And with the mobile trends, most products are now released as a mobile apps, and a web application.

The web is now the norm.
It is the application platform.
And because Javascript is programming language of the web, it is \textit{de facto} the language of choice to develop technologies.\ftnt{http://blog.codinghorror.com/javascript-the-lingua-franca-of-the-web/}

Some might consider HTML5 is not yet ready to build complete application on mobile, where condition in terms of performance, and accessibility are not as good as on the desktop.
But even in these cases, Javascript seems to remain the language of choice, as proven with React Native\ftnt{https://facebook.github.io/react-native/}, from Facebook, who prone the "learn once, write anywhere", in opposition to the "develop once deploy everywhere of the web".


\paragraph{Isomorphic Javascript}

https://www.meteor.com/

https://facebook.github.io/flux/

\paragraph{Reactive}

http://facebook.github.io/react/

Code reuse.
Why it never worked ?





https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript

The Atom editor is written in Javascript node.js.



Now, major PaaS (which one) support node.js by default.

Heroku support Python, Java, Ruby, Node.js, PHP, Clojure and Scala

Amazon Lambda Web service support node.js in priority.


>>> News :

npm raises 8m.
http://techcrunch.com/2015/04/14/popular-javascript-package-manager-npm-raises-8m-launches-private-modules/

% >>> I want to say that Javascript is now broadly used.
% Let's just look at the numbers : Javascript is the most popular language on Github, and npm has more package than any other package manager.
% Javascript has the more broadly deployed runtime.
% ... and so on
% >>> the conclusion is : Javascript is now a major language, and it is more than worth the consideration we are giving it in this PhD thesis.



\subsection{Overview of the language}

Javascript was released in a hurry, without a strong and directive philosophy.
During its evolution, it snowballed with different features to accommodate the community, and the usage it was made on the web. As a result Javascript contains various, and sometimes conflicting, programming paradigms.
It borrow its syntax from a procedural language, like C, and the object notation from an object-oriented language, like Java, but it provides a different inheritance mechanism, based on prototypes. Most of the implementation adopt an event-based paradigm, like the DOM\ftnt{http://www.w3.org/DOM/} and node.js\ftnt{https://nodejs.org/}.
And finally, event though it is not purely functional like Haskel, Javascript borrows some concepts from functional programming.

In this section, we focus on the last two programming paradigm, functional programming and event-based programming.
Javascript exposes two features from functional programming.
Namely, it treats functions as first-class citizen, and allows them to close on their defining context, to become closures.
We will explain these two features in details, and see how they are highly attractive to program in an event-based paradigm.

\subsubsection{Functions as First-Class citizens}

\cit{All problems in computer science can be solved by another level of indirection}{Butler Lampson}

Javascript treats function as first-class citizens.
One can manipulate functions like any other type (number, string ...).
She can store functions in variables or object properties, pass functions as arguments to other functions, and write functions that return functions.

The most common usage examples of these features, are the methods \texttt{Map}, \texttt{Reduce} and \texttt{filter}.
In the example below, the method \texttt{map} expect a function to apply on all the element of an array to modify its content, and output a modified array.
A function expecting a function as a parameter is considered to be a higher-order function. \texttt{Map}, \texttt{Reduce} and \texttt{Filter} are higher-order functions.

\begin{code}
  [4, 8, 15, 16, 23, 42].map(function firstClassFunction(element) {
    return element + 1;
  });
  // -> [5, 9, 16, 16, 24, 43]
\end{code}

Higher-order functions provide a new level of indirection, allowing abstractions over functions.
To understand this new level of abstraction, let's briefly summarize the different abstractions on the execution flow offered by programming paradigms.
In imperative programming, the control structures allow to modify the control flow. That is, for example, to execute different instructions depending on the state of the program.
Procedural programming introduces procedures, or functions. That is the possibility to group instructions together to form functions.
They can be applied in different contexts, thus allowing a new abstraction over the execution flow.
% It encourages to abstract program states so that the same function can be applied in different places to apply its behavior.

So, higher-order functions add another level of abstraction.
It allows to dynamically modify the control of the execution flow.
The ability to manipulate functions like any other value allows to abstract over functions, and behavior.
% TODO continue this, there is a lot to say about HOF

Higher-order functions replace the needs for some Object oriented programming design patterns.\ftnt{http://stackoverflow.com/a/5797892/933670} Though object oriented programming doesn't exclude higher-order functions.

They are particularly interesting when the behavior of the program implies to react to inputs provided during the runtime, as we will see later.
Web servers, or graphical user interfaces, for examples, interact with external events of various types.

% TODO transition : higher-order functions makes use of closure to implement the lexical scope in mutable programming languages. (reformulate)

\subsubsection{Closure}

\cit{An object is data with functions. A closure is a function with data.}{John D. Cook}

Closures are indissociable from the concept of lexical environment.
To understand the former, it is important to understand the latter first.

\paragraph{Lexical environment}

A variable is the very first level of indirection provided by programming languages and mathematics.
It is is a binding between a name and a value.
Mutable like in imperative programming to represent the reality of memory cells, or immutable like in mathematics and functional programming.
These bindings are created and modified during the execution.
They form a context in which the execution takes place.
To compartmentalize the execution, a context is also compartmentalized.
A certain context can be accessed only by a precise portion of code.
Most languages defines the scope of this context using code blocks as boundaries.
That is known as lexical scoping, or static scoping.
The variables declared inside a block represent the lexical environment of this block.
These lexical environments are organized following the textual hierarchy of code blocks.
The context available from a certain block of code, that is set of accessible variable, is formed as a cascade of the current lexical environment and all the parent lexical environment, up to the global lexical environment.

% TODO draw the schema for a lexical environment here

\paragraph{Javascript lexical environment}
\ftnt{http://www.ecma-international.org/ecma-262/5.1/\#sec-10.2}

Javascript implement lexical scoping with function definitions as boundaries, instead of code blocks.
The code below show a simple example of lexical scoping in Javascript.

\begin{code}
  var a = 4;
  var c = 6;
  function f() {
    var b = 5;
    var c = 0;
    // a and b are accessible here.
    return a + b + c;
  }

  f(); // -> 9

  // b is not accessible here :
  a + b + c; // -> ReferenceError: b is not defined
\end{code}

Lexical scoping, or statical scoping, implies that the lexical environment are known statically, at compile time for example.
But Javascript is a dynamic language, it doesn't truly provide lexical scoping.
In Javascript, the lexical environments can be dynamically modified using two statements : \texttt{with} and \texttt{eval}.
We explain in details the Javascript lexical scope in section \ref{??? Compiler stuff}

\paragraph{Closure}

A closure is the association of a first-class function with its context.
When a function is passed as an argument to an higher-order function, she closes over its context to become a closure.
When a closure is called, it still has access to the context in which it was defined.
The code below show a simple example of a closure in Javascript.
The function \texttt{g} is defined inside the scope of \texttt{f}, so it has access to the variable \texttt{b}.
When \texttt{f} return \texttt{g} to be assigned in \texttt{h}, it becomes a closure.
The variable \texttt{h} holds a closure referencing the function \texttt{g}, as well as its context, containing the variable \texttt{b}.
The closure \texttt{h} has access to the variable \texttt{b} even outside the scope of the function \texttt{f}.

\begin{code}
  function f() {
    var b = 4;
    return function g(a) {
      return a + b;
    }
  }

  var h = f();
  // b is not accessible here :
  b; // -> ReferenceError: b is not defined

  // h is the function g with a closure over b :
  h(5) // -> 9
\end{code}


% TODO continue with closure


% TODO transition, Higher-order functions and closures are very handy in turn-based programming


\subsection{Turn-based programming}

Javascript, like most programming languages, is synchronous and non-concurrent. The specification doesn't provide mechanism to write concurrent execution of Javascript.
There is no reference to \texttt{setTimeout} nor \texttt{setInterval}.
These two well-known instructions to asynchronously post-pone execution are provided by the DOM.
Indeed, like for many languages, concurrency is supported and provided by the execution engine.
For example the JVM in the case of Java, or the operating system in the case of C/C++.
These last two languages were mostly used to design CPU intensive applications.
The concurrency model for such application is driven by the need for computing power.
The best concurrency model is the threading model.
It allows to run multiple executions simultaneously to leverage the potential of parallel architectures, and execute faster.
Execution engine provide thread libraries to allow concurrency, like pthreads\ftnt{https://computing.llnl.gov/tutorials/pthreads/} for POSIX operating systems, and the \texttt{Thread}\ftnt{https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html} class for Java.
But, as we will see in a next chapter, threads are known to be very difficult to manipulate.
It is lucky that Javascript was not seen early as a language to build CPU intensive applications, so it can adopt a different concurrency model.

Indeed, Javascript was used from the beginning to build graphical user interfaces.
Since user interfaces evolved from a simple and sequential user prompt to a full interactive graphical space, the user interacts in a non-sequential way.
The interface needs to display and react to multiple streams of interaction.
% TODO find a good example here

The concurrency need is completely different than for CPU intensive applications, and so is the concurrency model.
Graphical user interfaces often use an event-loop.

When an event-loop is used as the concurrency model, it creates what Douglas Crockford called turn-based programming\ftnt{https://youtu.be/dkZFtimgAcM?t=1852}.

As event-loop was never used in CPU intensive applications, there was no need to extend to the multi-thread.
An event-loop is single-threaded, therefore, it always has exclusive access to its memory.
The concurrency is in a time-sliced fashion, each turn has an exclusive access on the memory by design.
And it is never preempted.
The event-loop let each event execute until it yield execution.
The event-loop provide concurrency without the need for synchronization on the form of mutual exclusions, and locks.
% TODO reformulate this paragraph, it is currently badly written.

However, it has a cost.
Each turn needs to be executed fast, so as to avoid the event-queue to congest on events waiting for their turn.


% TODO GUIs hardly ever congest the event-loop, because if the programmer is not so bad, event are fast, and there is usually not so much event : the graphical space is often limited to the attention of a single user.
% However, in the case of web application, there is a lot much more events to process.
% So much in fact, that the congestion of a single event-queue (see USL) is often impacting the latency, and the reactivity of the application.
% At this point, it is interesting to split into multiple event-queue.
% Continue integrating the scalability / concurrency, and follow to the problematic.


Now the browser has a thread-like concurrency model as well, on the form of web workers\ftnt{http://www.w3.org/TR/workers/}.


As said above, most implementations of Javascript feature an event-based programming paradigm.
The DOM\ftnt{http://www.w3.org/DOM/} and node.js\ftnt{https://nodejs.org/} are the most famous examples.


HOF allows Continuation Passing Style, which is particularly useful in a turn-based programming language such as node.js javascript.
% TODO continue to say a lot about CPS



\subsubsection{the Javascript event-loop}

Web pages are graphical environment offering multiple area of interaction for the user.
Because of this multiplicity, the traditional linear programing model doesn't hold anymore.
Graphical systems switched from this linear programming model to a different programming model focused on events.

Javascript uses higher-order functions.
It is the ability for a language to manipulate functions like any other value.
This ability is used to register a function to trigger after an event occurred.
An event might be the click on an element of the page, for example.

Such a function is named a callback, a handler, a listener ...
And it shift the programming paradigm from synchronous to asynchronous, which is a big deal.

In synchronous programming, the computation step are executed sequentially, one after the other.
The program execution follows perfectly the program layout written in a linear textual file.

On the other hand, asynchronous programming allows a step back from this linearity.


A multi-threaded system allows the developer to explicitly express the parallelism in the application.
A GOTO statement allows the developer to explicitly express the control flow in the application.


Asynchronous programming allows the program to manage the concurrency of the execution.
Unlike a linear layout of an imperative program, it allows to express more finely the dependencies between instructions.

% James Coglan speak about Promises and the abstraction they allow on the control flow. much interesting, especially at the end.
% https://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/

% >>> I want to say that Javascript is the first language broadly used with this asynchronous paradigm.
% Is asynchronous programming a step before declarative programming ?

\subsubsection{Promises}

% Douglas Crowford on Promises
% https://www.youtube.com/watch?v=dkZFtimgAcM

% The web is polluted with dumb, simple Promises tutorial for Javascript
% It is hard to find the relevant information about how Promises change the programmation paradigm.
