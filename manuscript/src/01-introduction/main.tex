\chapter{Introduction} \label{chapter:conclusion}
\minitoc
\eject

When the 7 years old I was laid amazed eyes on the first family computer, my life goal became to know everything there is to know about computers.
This thesis is a mild achievement.
It compiles my PhD work on a
% TODO TITLE HERE
% \textit{bridging the gap between development productivity and performance efficiency, in the case of real-time web applications}.
\textit{Fluxional compiler to bring seamless shift from development productivity to performance efficiency, in the case of real-time web applications}.

\illustration{amazed child in front of a computer}

This work is the fruit of a collaboration between the Worldline company and the Inria DICE team (Data on the Internet at the Core of the Economy) from the CITI laboratory (Centre d’Innovation en Télécommunications et Intégration
de services) at INSA de Lyon.
For Worldline, this work falls within a larger work named Liquid IT, on the future of the cloud infrastructure and development.
As defined by Worldline, Liquid IT aims at decreasing the time to market of a web application.
It allows the development team to focus on application specifications rather than technical optimizations and eases maintenance.
The purpose of this PhD work, was to separate development productivity from performance efficiency, to allow a continuous development from prototyping phase, until runtime on thousands of clusters.
On the other hand, the DICE team focuses on the consequences of technology on economical and social changes at the digital age.
This work falls within this scope as it studies the relation between the economical and the technological constraints driving the development of web applications.

\section{Web development}

% The growth of web applications is partially due to Internet's capacity to allow very quick releases of a minimal viable product (MVP).
Internet allows very quick releases of a minimal viable product (MVP).
% For web applications, it results in a rapid growth.
In a matter of hours, it is possible to release a prototype and start gathering a user community around.
\textit{``Release early, release often''}, and \textit{``Fail fast''} are the punchlines of the web entrepreneurial community.
It is crucial for the prosperity of a project to quickly validate that the proposed solution meets the needs of its users.
Indeed, the lack of market need is the first reason for startup failure.\ftnt{https://www.cbinsights.com/blog/startup-failure-post-mortem/}
Often the development team quickly concretises an MVP and iterates on it using a feature-driven and monolithic approach thanks to imperative languages like Java or Ruby.

\section{Performance requirements}

If the application successfully complies with users requirements, its user base might grow with its popularity.
The application is scalable when it can efficiently respond to this growth.
However, it is difficult to develop scalable applications with the feature-driven approach mentioned above.
Eventually this growth requires to discard the initial monolithic approach to adopt a more efficient processing model instead.
Many of the most efficient models distribute the application on a cluster of commodity machines.

Once split, the application parts are connected by an asynchronous messaging system.
Many tools have been developed to express and manage these parts and their communications.
However, these tools impose specific interfaces and languages, different from the initial monolithic approach.
It requires the development team either to be trained or to hire experts, and to start over the initial code base.
This shift causes the development team to spend development resources in background without adding visible value for the users.
It is a risk for the evolution of the project as the second and third reasons for startup failures are running out of cash, and missing the right competences.

\section{Problematic and proposal}

These shifts are a risk for the economical evolution of a web application by disrupting the continuity of its development process.
The main question addressed by this thesis is how to avoid these shifts, so as to allow a continuous development?
It implies the reconciliation between the productivity required in the early stage of development and the efficiency required with the growth of popularity.
To answer this question, this thesis proposes a solution based on the equivalence between two different programming models.
On one hand, there is the asynchronous, functional programming model, embodied by the Javascript event-loop.
On the other hand, there is the distributed, dataflow programming model, embodied by the pipeline architecture.

This thesis contains two main contributions.
The first contribution is a compiler allowing to split a program into a pipeline of stages depending on a common memory store.
The second contribution, stemming from the first one, is a second compiler, enforcing isolation between the stages of this pipeline.
With these two contributions, it is possible to transform the modular representation of an application into a pipeline representation.
The modular representation allows develoment productivity, while the pipeline representation carries its execution efficiently.
A development team shall then use these two representations to continuously iterate over the implementation of an application, and reach the best compromise between productivity and efficiency.

\section{Thesis organization}

This thesis is organized in six main chapters.
Chapter \ref{chapter2} introduces the context for this thesis and explains in greater details its objectives.
It presents the challenge to build web applications at a world wide scale, without jamming the organic evolution of its implementation.
It concludes drawing a first answer to this challenge.
Chapter \ref{chapter3} presents the works surrounding this thesis, and how they relate to it.
It defines the notions outlined in chapter \ref{chapter2} to help the reader understand better the context.
It finally presents clearly the problematic addressed in this thesis.
Chapter \ref{chapter4} introduces the proposition of this thesis, and the articulation of the contributions.
Chapter \ref{chapter5} presents the implementations of the two contributions.
% The first contribution allows to represent a program as a pipeline of stages.
% It introduces Dues, based on Javascript Promises, to layout the pipeline.
% The second contribution allows to make these stages independent.
% It introduces Fluxions to isolate these stages, and distribute the execution.
Finally, it evaluates this implementation at the light of the previous works, and draws the possible perspectives.
Finally, chapter \ref{chapter7} concludes this thesis.
