\chapter{Introduction} \label{chapter:conclusion}
\minitoc
\eject

When the amazed 7 years old I was laid eyes on the first family computer, my life goal became to know everything there is to know about computers.
This thesis is a mild achievement.
It compiles my PhD work on
% TODO TITLE HERE
\textit{bridging the gap between development scalability and performance scalability, in the case of real-time web applications}.

\illustration{amazed child in front of a computer}

This work is the fruit of a collaboration between the Worldline company and the Inria DICE team (Data on the Internet at the Core of the Economy) from the CITI laboratory (Centre d’Innovation en Télécommunications et Intégration
de services) at INSA de Lyon.
For Worldline, this work falls within a larger work named Liquid IT, on the future of the cloud infrastructure and development.
As defined by Worldline, Liquid IT aims at decreasing the time to market of a web service, allows the development team to focus on service specifications rather than technical optimizations and ease maintenance.
The purpose of this PhD work, was to separate development scalability from performance scalability, to allow a continuous development from prototyping phase, until runtime on thousands of clusters.
On the other hand, the DICE team focuses on the consequences of technology on economical and social changes at the digital age.
This work falls within this scope as it studies the relation between the economical and the technological constraints driving the development of web services.

\section{Web development}

The growth of web platforms is partially due to Internet's capacity to allow very quick releases of a minimal viable product (MVP).
In a matter of hours, it is possible to release a prototype and start gathering a user community around.
\textit{``Release early, release often''}, and \textit{``Fail fast''} are the punchlines of the web entrepreneurial community.
It is crucial for the prosperity of such project to quickly validate that the proposed solution meets the needs of its users.
Indeed, the lack of market need is the first reason for startup failure.\ftnt{https://www.cbinsights.com/blog/startup-failure-post-mortem/}
That is why the development team quickly concretises an MVP and iterates on it using a feature-driven, monolithic approach.
Such as proposed by imperative languages like Java or Ruby.

\section{Performance requirements}

If the service successfully complies with users requirements, its community might grow with its popularity.
The service is scalable when it can quickly respond to this growth.
However, it is difficult to develop scalable applications with the feature-driven approach mentioned above.
Eventually this growth requires to discard the initial monolithic approach to adopt a more efficient processing model instead.
Many of the most efficient models distribute the system on a cluster of commodity machines.

Once split, the service parts are connected by an asynchronous messaging system.
Many tools have been developed to express and manage these parts and their communications.
However, these tools impose specific interfaces and languages, different from the initial monolithic approach.
It requires the development team either to be trained or to hire experts, and to start over the initial code base.
This shift causes the development team to spend development resources in background without adding visible value for the users.
It is a risk for the evolution of the project as the second and third reasons for startup failures are running out of cash, and missing the right competences.

\section{Problematic and proposal}

These shifts are a risk for the economical evolution of a web application by disrupting the continuity of its development process.
The main question addressed by this thesis is how to avoid these shifts, so as to allow a continuous development?
That is to reconcile the reactivity required in the early stage of development and the performance increasingly required with the growth of popularity.
To answer this question, this thesis proposes a solution based on an equivalence between two different programming paradigms.
On one hand, there is the imperative, functional, asynchronous programming model, embodied by Javascript.
On the other hand, there is the dataflow, distributed, programming model, embodied by the concept of fluxions introduced in chapter \ref{chapter5}.

This thesis contains two main contributions.
The first contribution is a compiler allowing to split a program into a pipeline of stages depending on a common memory store.
The second contribution, stemming from the first one, is a second compiler, allowing to make independent the stages of this pipeline.
With these two contributions, it is possible to build a compiler that links an imperative representation with a flow-based representation.
The imperative representation carries the functional modularization of the application, while the flow-based representation carries its execution distribution.
A development team shall then use these two representations to continuously iterate over the implementation of an application, and reach both maintainability and performance.

\section{Thesis organization}

This thesis is organized in four main chapters.
Chapter \ref{chapter2} introduces the context for this thesis and explains in greater details its objectives.
It presents the challenge to build web applications at a world wide scale, without jamming the organic evolution of its implementation.
It concludes drawing a first answer to this challenge.
Chapter \ref{chapter3} presents the works surrounding this thesis, and how they relate to it.
It defines into the notions outlined in the precedent chapter to help the reader understand better the context.
The end of this chapter presents clearly the problematic addressed in this thesis.
Chapter \ref{chapter4} presents the first contribution allowing to represent a program as a pipeline of stages.
It introduces Dues to encapsulate these stages, based on Javascript Promises.
Chapter \ref{chapter5} presents the second contribution allowing to make these stages independent.
It introduces Fluxion to encapsulate these stages.
Chapter \ref{chapter6} concludes this thesis, and draws the possible perspectives beyond this work.
