\section{Development growth}

Separation of concerns is a design principle to modularize an application into module so that each module has a specific concern.
It feels like an rephrasing of information hiding.
SoC needs encapsulation, for example via OOP, or layered programming (structured design).
SoC assures the principle of locality.

Separation of concerns is not what I thought !!!!!
Dijkstra \cite{Dijkstra1982} wrote that it is about analyzing different aspects of a program, not different modules.
Dijkstra gives the example of analyzing correctness and efficiency independently.
However, now it seems to have drifted into layered design, and now into modularization.
(See wikipedia page https://en.wikipedia.org/wiki/Separation_of_concerns)


A first part with the modularity, from Parnas with Information Hiding, to modularity, and design decision, and design structure matrix, and so on ...
To Object, with object calisthenics.
This part should show roughly the trend in software modularity.

A second part with the incompatibility between this modularity and parallelism.
This part might need to move into the reconciliation part.


\subsubsection{Structured Design}

Letters to the editor : goto statement considered harmful \cite{Dijkstra1968a}
Structured Design \cite{Stevens1974}
The structure of the THE-multiprogramming system \cite{Dijkstra1968}



\subsubsection{Information Hiding Principles}

Reference paper :
On the criteria to be used in decomposing systems into modules \cite{Parnas1972}


The structure and value of modularity in software design \cite{Sullivan2001a}
-> We identify an issue for software designers that neither Parnasâ€™s formulation nor subsequent developments based on it adequately address: A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.


\subsubsection{Modularity based on Design Decisions}

Designing Software for ease of extension and contraction \cite{Parnas1979}

Design Rules: The Power of Modularity Volume 1 \cite{Baldwin1999}
A reference book, but can't get it.

Design Rule Hierarchies and Parallelism in Software Development Tasks \cite{Wong2009}
Organize design, so that modules can be developed in parallel, without communication between teams working on independent modules.
Identification of coordination requirements \cite{Cataldo2006}
About the communication requirement between teams working on different modules.

If the teams working on different modules need not to communicate, then the same person working on different modules at different times, need not to remember any dependencies : both conserves locality of reasoning.


\subsubsection{Locality}

The Software Principle of Locality \cite{Dobson}
Not a very good article, but advocate principle of locality :
the person working closely, in terms of both space and time, to an artefact is the most qualified person to remove defects associated with it. This


\subsubsection{Object Oriented Programming}

Interestingly enough, Object Oriented Programming, as defined by Alan Kay, who coined the term, is based on the definition of the Actor Model.

\begin{enumerate}
\item Everything is an object.
\item Communication is performed by objects communicating with each other, requesting that objects perform actions. Objects communicate by sending and receiving messages. A message is a request for action, bundled with whatever objects may be necessary to complete the task.
\item Objects have their own memory, which consists of other objects.
\item Every object is an instance of a class. A class simply represents a grouping of similar objects, such as integers or lists.
\item The class is the repository for behavior associated with an object. That is, all objects that are instances of the same class can perform the same actions.
\end{enumerate}

\endinput

Since the beginning of software development, software systems are designed as the composition of smaller subsystems.\nt{Find exact reference of this}

The first one follows the Information Hiding principle, firstly stated by Parnas, in 1972 in his paper On the criteria to be used in decomposing systems into modules.

Dijkstra coined the term hierarchical structure in a paper presenting the decomposition of a multiprogramming system.
Basically what we could consider a simple operating system.

This paper also presents the what seems to be the very first concept of mutual exclusion, what is now regarded as an extremely difficult concept to master in concurrent programming.

In 2009 we can cite Wong, Design Rule Hierarchies and Parallelism in Software Development Tasks, that aim at improving the parallelism in development tasks.


But I am sure there is a lot more to find.
\begin{itemize}
  \item Structured Programming
  \item Hierarchical structure
  \item OOP
\end{itemize}





\endinput


Making state explicit for imperative big data processing \cite{Fernandez2014a}

Prospect: Finding and Exploiting Parallelism in a Productivity Language for Scientific Computing
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk

Where is software headed ? \cite{Lewis1995}
-> Comparison between academic and industrial roadmap for software.

Now every programming languages use pass-by-reference, or pass-by-sharing to make use of the common memory storage.
Developers were always comfortable with this kind of storage abstraction.
It made sequential programming almost as efficient, and sometimes more, than parallel programming because of the optimization on sequential programming, and the difficulty and the lack of optimization of parallel programming.



I need to show that the 1) languages the more used are sequential with a common memory storage, because 2) it is inherently difficult to program with distributed memory storage.
3) I need to show that the best practice of software development require this common memory storage.

See Object calisthenics 
- http://williamdurand.fr/2013/06/03/object-calisthenics/
- http://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf