\section{Development growth}

TODO introduction

\subsection{Modularity}

TODO introduction

\subsubsection{Structured Programming}

In the history of software development, at some point the size and complexity of software system urges the developers to split the problem into isolated subproblems.
Dijkstra was maybe the first to encounter and formalize this procedure.

A program expressed as a suites of instructions with occasional jumps makes the flow of control very hard to follow and understand.
We say it is spaghetti code.
Instead, Dijkstra advocated to forbid the use of the \texttt{goto} statement, and decompose the implementation into functions to be called and returned \cite{Dijkstra1968a}.
This would allow to split the main problem into many subproblems encapsulated into reusable, and isolated functions.
This is called structured programming, and it impacts the development at a fine grain by restricting the usage of the control flow.

Following this, he proposed to design complex systems with a hierarchical structure \cite{Dijkstra1968}.
Each layer would abstract a design problem for the upper layers.
This work established grounds for what is know called modular programming.

% Letters to the editor : goto statement considered harmful \cite{Dijkstra1968a}
% The structure of the THE-multiprogramming system \cite{Dijkstra1968}

\subsubsection{Structured Design}

Modular programming advocates to design a software system as an ensemble of modules communicating with each other.
When designing the modules, two properties are crucial, coupling and cohesion \cite{Stevens1974}.

The coupling defines the strength of the interdependence between modules.
It is opposed as cohesion which defines how strongly the features inside a module are related.
Low coupling between modules and high cohesion inside modules implies a better understanding and readability of the source code of the system.

The relations between features, necessary to define the module organization, needs to be well defined.
These relation will define the boundary of modules, and how the features should be put in those modules.


% (See wikipedia page https://en.wikipedia.org/wiki/Separation_of_concerns)


\subsection{Design choices}

TODO introduction

\subsubsection{Separation of concerns}

Dijkstra \cite{Dijkstra1982} coined the terms separation of concerns more than thirty years ago, but this concept drifted and loosed its initial meaning.
It is interesting to note the difference between the two meanings.
Initially, the separation of concerns meant the ability to reason about different properties of a software system.
My understanding of this definition, was not to encapsulate different concerns into different modules, but to analyze how a system possesses certain properties.
Dijkstra gives the example of analyzing correctness and efficiency independently.
In this respect, this thesis is completely oriented towards separating the concern of development maintainability and the concern of performance.
That is to be able to reason on the maintainability of a program, independently than of its performance, and vice versa.

However, separation of concerns seems rightfully to mean a different concept \cite{Tarr1999,Hursch1995}.
Separation of concerns is now understood as a design principle advocating that each module has a specific concern in a modular design.
For example, the separation of the form and the content in Latex, or in HTML / CSS are example of this new meaning for separation of concerns.

The drift in meaning seems to come from a confusion between a concern one have about this system, which is a property of the system (efficiency, readability, correctness), and a design choice to encapsulate to avoid impacting the whole system.

\subsubsection{Information hiding principle}

To my understanding, the new meaning of Separation of Concerns feels similar to the definition of information hiding.

Information hiding was defined by Parnas \cite{Parnas1972} as a way to define the organization of modules.
The intention was to encapsulate specific design choice in each module so as to limit the impact of the modification of a choice on the rest of the system.

In this article, Parnas clearly oppose the definition of modules following the flow of data through the execution, and the definition of modules following the information hiding principle.
In this thesis, we shall investigate further this opposition.



\subsection{Programming models}

TODO introduction

\subsubsection{Object oriented programming}

The following list define Object-Oriented Programming (OOP).

\begin{enumerate}
\item Everything is an object.
\item Communication is performed by objects communicating with each other, requesting that objects perform actions. Objects communicate by sending and receiving messages. A message is a request for action, bundled with whatever objects may be necessary to complete the task.
\item Objects have their own memory, which consists of other objects.
\item Every object is an instance of a class. A class simply represents a grouping of similar objects, such as integers or lists.
\item The class is the repository for behavior associated with an object. That is, all objects that are instances of the same class can perform the same actions.
\end{enumerate}

Though the recent concept of Object-oriented programming focus strongly on the notion of object as an encapsulation principle, Alan Kay who coined the term, insisted in a public mail exchange that the original concept he envisioned is about message-passing, more than inheritance.

Interestingly enough, Object Oriented Programming, as defined by Alan Kay, who coined the term, is based on the definition of the Actor Model.



\paragraph{Object calisthenics}

Object calisthenics are defined as the chapter 6 of \cite{Bay2008}.
It is an exercise presented as a list of 9 rules to follow to enforce maintainability and readability of your code.

Some of these rules are direct implementations of the more general concept of separation of concerns, and information hiding.
Rule 7 Keep all entities small, for example is similar somehow to say that entities should have a clear concern.
Other rules are just plain syntactic rules to improve readability and comprehensibility.


See Object calisthenics 
- http://williamdurand.fr/2013/06/03/object-calisthenics/
- http://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf



\subsubsection{Another programming model ?}

TODO



\endinput







Plan

A first part with the modularity, from Parnas with Information Hiding, to modularity, and design decision, and design structure matrix, and so on ...
To Object, with object calisthenics.
This part should show roughly the trend in software modularity.

A second part with the incompatibility between this modularity and parallelism.
This part might need to move into the reconciliation part.






\subsubsection{Information Hiding Principles}

Reference paper :
On the criteria to be used in decomposing systems into modules \cite{Parnas1972}


The structure and value of modularity in software design \cite{Sullivan2001a}
-> We identify an issue for software designers that neither Parnasâ€™s formulation nor subsequent developments based on it adequately address: A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.


\subsubsection{Modularity based on Design Decisions}

Designing Software for ease of extension and contraction \cite{Parnas1979}

Design Rules: The Power of Modularity Volume 1 \cite{Baldwin1999}
A reference book, but can't get it.

Design Rule Hierarchies and Parallelism in Software Development Tasks \cite{Wong2009}
Organize design, so that modules can be developed in parallel, without communication between teams working on independent modules.
Identification of coordination requirements \cite{Cataldo2006}
About the communication requirement between teams working on different modules.

If the teams working on different modules need not to communicate, then the same person working on different modules at different times, need not to remember any dependencies : both conserves locality of reasoning.


\subsubsection{Locality}

The Software Principle of Locality \cite{Dobson}
Not a very good article, but advocate principle of locality :
the person working closely, in terms of both space and time, to an artefact is the most qualified person to remove defects associated with it. This















\subsubsection{Contradiction}


To understand the problem of incompatibility between the modular design and the parallel execution, one can think about the communication between two stages.
The result output by one stage needs to be understood by the next.
There need to be a common understanding on the nature, and the structure of this result.
The modular design advocates that this common ground, the interface, be the most immutable possible, the most solid possible.
While the parallel execution defines interfaces between the stages.



\endinput

Since the beginning of software development, software systems are designed as the composition of smaller subsystems.\nt{Find exact reference of this}

The first one follows the Information Hiding principle, firstly stated by Parnas, in 1972 in his paper On the criteria to be used in decomposing systems into modules.

Dijkstra coined the term hierarchical structure in a paper presenting the decomposition of a multiprogramming system.
Basically what we could consider a simple operating system.

This paper also presents the what seems to be the very first concept of mutual exclusion, what is now regarded as an extremely difficult concept to master in concurrent programming.

In 2009 we can cite Wong, Design Rule Hierarchies and Parallelism in Software Development Tasks, that aim at improving the parallelism in development tasks.


But I am sure there is a lot more to find.
\begin{itemize}
  \item Structured Programming
  \item Hierarchical structure
  \item OOP
\end{itemize}





\endinput


Making state explicit for imperative big data processing \cite{Fernandez2014a}

Prospect: Finding and Exploiting Parallelism in a Productivity Language for Scientific Computing
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk

Where is software headed ? \cite{Lewis1995}
-> Comparison between academic and industrial roadmap for software.

Now every programming languages use pass-by-reference, or pass-by-sharing to make use of the common memory storage.
Developers were always comfortable with this kind of storage abstraction.
It made sequential programming almost as efficient, and sometimes more, than parallel programming because of the optimization on sequential programming, and the difficulty and the lack of optimization of parallel programming.



I need to show that the 1) languages the more used are sequential with a common memory storage, because 2) it is inherently difficult to program with distributed memory storage.
3) I need to show that the best practice of software development require this common memory storage.

See Object calisthenics 
- http://williamdurand.fr/2013/06/03/object-calisthenics/
- http://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf