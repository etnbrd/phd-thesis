\section{Development growth}

TODO

\endinput

Since the beginning of software development, software systems are designed as the composition of smaller subsystems.\nt{Find exact reference of this}

The first one follows the Information Hiding principle, firstly stated by Parnas, in 1972 in his paper On the criteria to be used in decomposing systems into modules.

Dijkstra coined the term hierarchical structure in a paper presenting the decomposition of a multiprogramming system.
Basically what we could consider a simple operating system.

This paper also presents the what seems to be the very first concept of mutual exclusion, what is now regarded as an extremely difficult concept to master in concurrent programming.

In 2009 we can cite Wong, Design Rule Hierarchies and Parallelism in Software Development Tasks, that aim at improving the parallelism in development tasks.


But I am sure there is a lot more to find.
\begin{itemize}
  \item Structured Programming
  \item Hierarchical structure
  \item OOP
\end{itemize}




Now every programming languages use pass-by-reference, or pass-by-sharing to make use of the common memory storage.
Developers were always comfortable with this kind of storage abstraction.
It made sequential programming almost as efficient, and sometimes more, than parallel programming because of the optimization on sequential programming, and the difficulty and the lack of optimization of parallel programming.



I need to show that the 1) languages the more used are sequential with a common memory storage, because 2) it is inherently difficult to program with distributed memory storage.
3) I need to show that the best practice of software development require this common memory storage.

See Object calisthenics 
- http://williamdurand.fr/2013/06/03/object-calisthenics/
- http://www.cs.helsinki.fi/u/luontola/tdd-2009/ext/ObjectCalisthenics.pdf