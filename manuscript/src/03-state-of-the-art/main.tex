\chapter{Software Design, State Of The Art} \label{chapter3}
\minitoc
\eject

\cit{A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.}{K. Sullivan, W. Griswold, Y. Cai, B. Hallen \cite{Sullivan2001a}}

\nt{TODO the next paragraph expresses well the idea, but is not clear enough yet}
The growth of the web and Software as a Service (SaaS) revealed the importance of previously unknown economic constraints.
The same company carries both development and exploitation of a service in scale of unprecedented size.
Development costs are reduced by following best practice, and by building maintainable softwares.
However, as seen in the previous chapter, it is compensated by increasing hardware performance, which eventually rises exploitation costs.
Similarly, exploitation costs are reduced by following more efficient programming models.
But again, it rises development costs.
So a SaaS company needs to cleverly allocate its budget between development and exploitation so as to limit the overall cost.

Eventually, a company faces the problem of scalability limitations.Compensating development with hardware becomes unsustainable.
The company has no choice but to commit huge development efforts to get correct performances.
This chapter draws a broad view of the relation between the orientation of development toward maintainability or scalable performance, and its consequences.

The best practices in software design advocate to decompose a problem into many subproblems.
The decomposition of the implementation of a problem improves directly its maintainability, development scalability and evolution.
This chapter present some of these best practices, \textit{e.g.} modular programming, structured design \cite{Stevens1974}, hierarchical structure \cite{Dijkstra1968} and object-oriented programming.

A few decades ago, the best practices were not concerned with execution performance.
Moore's law \cite{Moore1965} was wrongly interpreted as the assurance that hardware could always increase execution speed.
But eventually, the clock speed of processors plateaued \ftnt{https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/}\cite{Bohr2007}, and the processing units were organized as several execution units to continue improving performances.
But this hardware improvement could not anymore increase the execution speed without any additional development effort.

The best practices of software design then inherited two goals : to assure a scalable implementation evolution by decomposing it into subproblems, as well as assure a scalable parallel execution by decomposing the execution onto the several execution units.
As D. L. Parnas showed in 1972 \cite{Parnas1972}, it seems challenging to develop a software following a decomposition that satisfies both goals.

\begin{center}
\includegraphics[width=0.6\textwidth]{../ressources/state-of-the-art.pdf}
\end{center}

The evolution of economic constraints often force an SaaS company to switch from scalable development to scalable performance.
This switch implies huge development efforts.
There has been many attempts at reconciling the two goals to reduce these costs.
But none seems really convincing enough to be widely adopted.

The schema above is a graphical representation of the organization of this chapter, and more generally of the state of the art of software design.
The focus on development scalability, noted by number 1, are addressed in section \ref{chapter3:software-maintainability} while the focus on performance scalability, noted by number 3, are addressed in section \ref{chapter3:software-performance}.
Each of these direction of development contains works trying to meet the requirements from the opposing category, noted by number 2 and 4.
And finally, section \ref{chapter3:objectives} presents the objectives for this thesis, noted by number 5.




Present the criteria used for this analysis : 
- higher-order programming, closures, lazy evaluation / stream (not clear)
The expressiveness of a language comes from modularity, which comes from hop and lazy evaluation, because it allows abstraction.
But immutability is difficult, so closures are a good thing too.
So maintainability requires all three.

- shared state (r/w), immutable shared state (r/ø), isolation (ø/ø)
Scalability is about shared state at a fine level, and immutability and isolation at a coarser level.


The state of the art highlights that
\begin{itemize}
\item maintainability requires lazy-evaluation and higher-order programming, section \ref{chapter3:software-maintainability:programming-models:functional-programming}, and
\item higher-order programming requires a global memory abstraction, section \ref{chapter3:software-maintainability:modular-programming:limitations},
\end{itemize}
Javascript is a functional language that features higher-order programming and a global memory abstraction.
% Moreover, its dynamic natures allows a lot of flexibility for the developers.
Moreover, node.js features a streaming approach with the event-loop execution model, similar to the lazy evaluation.
These reasons make Javascript a language of choice for developing web application.

And that
\begin{itemize}
\item scalable performance requires parallelism, and
\item parallelism requires exclusive accesses on the state through isolation and immutability.
\end{itemize}
Eventually, web development is heading toward a streaming approach with pipeline processing.

\nt{TODO dependency schema of these highlights}



The composition of modules with low coupling is provided by encapsulation, higher-order programming and lazy evaluation.
Hence, the criteria to analyze the solutions presented in this section regarding maintainability are :
\begin{itemize}
\item encapsulation mechanism
\item presence of higher-order programming
\item presence of lazy evaluation, or stream composition
\end{itemize}
The last two criteria provide composition abstractions to design solutions from smaller components.
Encapsulation and composition are the features in modular programming that produce maintainability.




A system is maintainable only if there is competences available to maintain it.

The criteria to analyze the solutions presented in this section regarding the organic growth are : 
\begin{itemize}
\item adoption by the community
\item adoption by the industry
\item supporting web technologies
\end{itemize}
The first two criteria make sure that the technology is growing organically with a passionate community, and backed by industrial needs.
The last criteria assures the fitting of the technologies with our economical context of a web application. 




Maybe take some parts from chapter 2 to put into industry (all the languages comparison stuffs that barely belong in the context).

\input{03-state-of-the-art/Software-maintainability}
\input{03-state-of-the-art/Software-performance}
\input{03-state-of-the-art/Software-abstraction}
\input{03-state-of-the-art/Analysis}

% GOTO chapter 4 - proposition
% \input{03-state-of-the-art/Objectives}



%-----------------------------------------------------------------------------%
                                    \endinput
%-----------------------------------------------------------------------------%


Some links I NEED to put :
--------------------------

https://glyph.twistedmatrix.com/2014/02/unyielding.html
http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/

Transitions :
  - Linkedin - http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin
  - Facebook - https://www.cs.princeton.edu/events/event/evolution-software-architecture-facebook / http://www.infoq.com/presentations/Evolution-of-Code-Design-at-Facebook
  - ... 

https://medium.com/@benorama/the-evolution-of-software-architecture-bd6ea674c477

https://en.wikipedia.org/wiki/Dataflow
https://en.wikipedia.org/wiki/Real-time_computing
https://en.wikipedia.org/wiki/Partitioned_global_address_space
https://en.wikipedia.org/wiki/SPMD

Albert Cohen
https://scholar.google.com/citations?user=MkKZKAMAAAAJ&hl=en

+ Paul Feautrier (Tutor of A. Cohen)


Similar problem :
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk
http://www.cs.indiana.edu/~lkuper/papers/lindsey-kuper-dissertation.pdf

PJS was abandoned :
https://groups.google.com/forum/#!topic/mozilla.dev.tech.js-engine/H-YEsejE6DA
https://bugzilla.mozilla.org/show_bug.cgi?id=1117724

See parallel JS for further work (maybe) :
http://smallcultfollowing.com/babysteps/blog/2014/04/24/parallel-pipelines-for-js/

Some chunks I might find useful later :
---------------------------------------

A good example of declarative sentence in everyday world : in case of fire, 
the elevators don't work -> you understand that you need to take the stairs.