\chapter{Software Design, State Of The Art} \label{chapter3}
\minitoc
\eject

\cit{A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.}{K. Sullivan, W. Griswold, Y. Cai, B. Hallen \cite{Sullivan2001}}

With the growth of Software as a Service (SaaS) on the web, the same company carries both development and exploitation of an application at scale of unprecedented size.
It revealed the importance of previously unknown economic constraints.
To assure the continuous growth and sustainability of an application, it needs to address two contradictory goals : development productivity and performance efficiency.
These goals needs to be enforced by the platform supporting the application to build good development habits for the developers.
% In this chapter,
A platform designates any solution that allows to build an application on top of it, including programming languages, compilers, interpreters, frameworks, runtime libraries and so on.

\textit{75\% of your budget is dedicated to software maintenance.}\ftnt{http://www.castsoftware.com/glossary/software-maintainability}
The productivity of a platform is the degree to which developers can quickly produce new and modify existing software.
It impacts the maintainability of the applications and relies on the modularity enforced by its platform.
Especially, higher order programming is crucial to build and compose modules productively.
It relies either on mutable states, or immutable states, but hardly on a combination of both.

However, neither mutable nor immutable states allows performance efficiency.
Mutable states leads to synchronization overhead at a coarser-grain level, while immutable states leads to communication overhead at a finer-grain level.
Efficiency relies on a combination of synchronization at a fine-grain level, and immutable message passing at a coarse-grain level.
This combination breaks the modularity, hence the productivity of an application.
A company has no choice but to commit huge development efforts to get efficient performances.

\illustration{virtuous circle between community and industry}
Moreover, a balance between productivity and efficiency is required for a platform to enter a virtuous circle of adoption.
The productivity is required to be appealing to gather a community to support the ecosystem around the platform.
This community is appealing for the industry as a hiring pool.
Additionally, the efficiency is required to be adopted by the industry to be economically viable.
And the industrial relevance provides the reason for this ecosystem to exist and the community to gather.

This chapter presents a broad view of the state of the art in the compromises between productivity and efficiency.
It defines software productivity, efficiency, and adoption in section \ref{chapter3:definitions} and all the underlying concepts, such as higher order programming and state mutability.
It then analyzes different platforms according to their focus. platforms focusing on productivity are addressed in section \ref{chapter3:software-productivity}, those focusing on efficiency in section \ref{chapter3:software-efficiency} and those focusing on a compromise between the two in section \ref{chapter3:software-abstraction}.

\input{03-state-of-the-art/tables}

\input{03-state-of-the-art/Definitions}
\input{03-state-of-the-art/Software-productivity}
\input{03-state-of-the-art/Software-efficiency}
\input{03-state-of-the-art/Software-adoption}


\section{Analysis}

This chapter presented a broad view of platforms and their balance between productivity or efficiency.
The platforms favoring one sacrifice the other.
The adoption, and usage of these platforms prove that none of these compromises are sustainable.

The productive platforms are highly adopted.
Their productivity feed a reinforcing circle of adoption between the community and the industry.
However, they lack the efficiency required to strive in the latter stage of a project, where efficiency becomes crucial.

On the other hand, the efficient platforms are not widely adopted by the community.
These platforms are unable to respond to the need of the community to prototype and to experiment on small projects to make them evolve into larger ones later on.


\paragraph{Continuous Development}

It is not possible for a platform to support both productivity and efficiency at the same time.
These platforms are oriented toward productivity, efficiency or a compromise between both.
As the two are required at different time in the evolution of the project, to follow a project, a platform need to meet the requirements at the good time.
They need to supporting productivity to allow the community to experiment, and organically start projects.
And then continuously shift toward efficiency as the project evolve, and requires it.

None of these platforms are able to support productivity then efficiency to follow the evolution of a project.
They lack the possibility to make a project evolve from the very early stage until maturation. 
A project needs to change platform to change the priority.
These shifts of platforms have economical consequences.

\paragraph{}

The table \ref{tab:summary} summarizes the analysis of the state of the art presented in this chapter.

\TableSummary{tab:summary}

%-----------------------------------------------------------------------------%
                                    \endinput
%-----------------------------------------------------------------------------%


Some links I NEED to put :
--------------------------

https://glyph.twistedmatrix.com/2014/02/unyielding.html
http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/

Transitions :
  - Linkedin - http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin
  - Facebook - https://www.cs.princeton.edu/events/event/evolution-software-architecture-facebook / http://www.infoq.com/presentations/Evolution-of-Code-Design-at-Facebook
  - ... 

https://medium.com/@benorama/the-evolution-of-software-architecture-bd6ea674c477

https://en.wikipedia.org/wiki/Dataflow
https://en.wikipedia.org/wiki/Real-time_computing
https://en.wikipedia.org/wiki/Partitioned_global_address_space
https://en.wikipedia.org/wiki/SPMD

Albert Cohen
https://scholar.google.com/citations?user=MkKZKAMAAAAJ&hl=en

+ Paul Feautrier (Tutor of A. Cohen)


Similar problem :
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk
http://www.cs.indiana.edu/~lkuper/papers/lindsey-kuper-dissertation.pdf

PJS was abandoned :
https://groups.google.com/forum/#!topic/mozilla.dev.tech.js-engine/H-YEsejE6DA
https://bugzilla.mozilla.org/show_bug.cgi?id=1117724

See parallel JS for further work (maybe) :
http://smallcultfollowing.com/babysteps/blog/2014/04/24/parallel-pipelines-for-js/

Some chunks I might find useful later :
---------------------------------------

A good example of declarative sentence in everyday world : in case of fire, 
the elevators don't work -> you understand that you need to take the stairs.