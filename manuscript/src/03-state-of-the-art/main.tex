\chapter{Software Design, State Of The Art} \label{chapter3}
\minitoc
\eject

\cit{A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.}{K. Sullivan, W. Griswold, Y. Cai, B. Hallen \cite{Sullivan2001}}

The growth of the web and Software as a Service (SaaS) revealed the importance of previously unknown economic constraints.
The same company carries both development and exploitation of an application at scale of unprecedented size.
To allow a continuous growth and sustainability of an application, it needs to address two contradictory goals : maintainability and performance efficiency.
These goals needs to be enforced by the platform supporting the application to build good development habits for the developers.
% In this chapter,
A platform designates any solution that allows to build an application on top of it, including programming languages, compilers, interpreters, frameworks, runtime libraries and so on.

\textit{75\% of your budget is dedicated to software maintenance.}\ftnt{http://www.castsoftware.com/glossary/software-maintainability}
The maintainability of an application relies on the modularity enforced by the platform used to build it.
Especially, higher order programming is crucial to build and compose modules efficiently.
It relies either on mutable states, or immutable states, but hardly on a combination of both.

However, neither mutable nor immutable states allow performance efficiency.
Mutable states leads to synchronization overhead at coarser-grain level, while immutable states leads to communication overhead at finer-grain level.
Performance efficiency relies on a combination of shared mutable state at a fine-grain level, and immutable message passing at a coarse-grain level.
This combination breaks the modularity, hence the maintainability of an application.
A company has no choice but to commit huge development efforts to get efficient performances.

\illustration{virtuous circle between community and industry}
Moreover, a balance between these two contradictory goals is required for a platform to enter a virtuous circle of adoption.
The maintainability is required to be appealing to gather a community to support the ecosystem around the platform.
This community is appealing for the industry as a hiring pool.
The performance efficiency is required to be adopted by the industry to be economically viable.
And the industrial relevance provides the reason for this ecosystem to exist and the community to gather.

This chapter presents a broad view of the state of the art in the compromises between maintainability and performance efficiency.
It defines software maintainability, performance efficiency, and adoption in section \ref{chapter3:definitions} and all the underlying concepts, such as higher order programming and state mutability.
It then analyzes different platforms according to their focus. platforms focusing on maintainability are addressed in section \ref{chapter3:software-maintainability}, those focusing on performance efficiency in section \ref{chapter3:software-performance} and those focusing on a compromise between the two in section \ref{chapter3:software-abstraction}.

\input{03-state-of-the-art/tables}

\input{03-state-of-the-art/Definitions}
\input{03-state-of-the-art/Software-maintainability}
\input{03-state-of-the-art/Software-performance}
\input{03-state-of-the-art/Software-abstraction}


\section{Analysis}

This chapter presented a broad view of platforms and their balance between productivity or efficiency.
The platforms favoring productivity sacrifice efficiency, and on the contrary, the platforms favoring efficiency sacrifice productivity.
The adoption, and usage of these platforms prove that none of these solutions are satisfying.

The productive platforms are highly adopted.
Their productivity feed a reinforcing circle of adoption between the community and the industry.
However, they lack the efficiency required to strive in the latter stage of a project, where efficiency becomes crucial.

On the other hand, the efficient platforms are not widely adopted by the community.
These platforms are unable to respond to the need of the community to prototype and to experiment on small projects to make them evolve into larger ones later on.

It is not possible for a platform to support both productivity and efficiency at the same time.

\paragraph{Continuous Development}

But more importantly, these platforms are oriented toward productivity, efficiency or a compromise between both.
As the two are required at different time in the evolution of the project, to follow a project, a platform need to meet the requirements at the good time.
They need to let the development team choose to start the project by supporting productivity.
And then continuously shift toward efficiency as the project evolve, and requires it.

None of these platforms are able to support productivity then efficiency to follow the evolution of a project.
They lack the possibility to make a project evolve from the very early stage until maturation. 
The project need to change platform to change the priority.
These shifts of platforms have economical consequences.

\TableSummary

%-----------------------------------------------------------------------------%
                                    \endinput
%-----------------------------------------------------------------------------%


Some links I NEED to put :
--------------------------

https://glyph.twistedmatrix.com/2014/02/unyielding.html
http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/

Transitions :
  - Linkedin - http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin
  - Facebook - https://www.cs.princeton.edu/events/event/evolution-software-architecture-facebook / http://www.infoq.com/presentations/Evolution-of-Code-Design-at-Facebook
  - ... 

https://medium.com/@benorama/the-evolution-of-software-architecture-bd6ea674c477

https://en.wikipedia.org/wiki/Dataflow
https://en.wikipedia.org/wiki/Real-time_computing
https://en.wikipedia.org/wiki/Partitioned_global_address_space
https://en.wikipedia.org/wiki/SPMD

Albert Cohen
https://scholar.google.com/citations?user=MkKZKAMAAAAJ&hl=en

+ Paul Feautrier (Tutor of A. Cohen)


Similar problem :
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk
http://www.cs.indiana.edu/~lkuper/papers/lindsey-kuper-dissertation.pdf

PJS was abandoned :
https://groups.google.com/forum/#!topic/mozilla.dev.tech.js-engine/H-YEsejE6DA
https://bugzilla.mozilla.org/show_bug.cgi?id=1117724

See parallel JS for further work (maybe) :
http://smallcultfollowing.com/babysteps/blog/2014/04/24/parallel-pipelines-for-js/

Some chunks I might find useful later :
---------------------------------------

A good example of declarative sentence in everyday world : in case of fire, 
the elevators don't work -> you understand that you need to take the stairs.