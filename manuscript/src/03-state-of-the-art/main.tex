\chapter{Software Design, State Of The Art} \label{chapter3}
\minitoc
\eject

\cit{A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.}{K. Sullivan, W. Griswold, Y. Cai, B. Hallen \cite{Sullivan2001}}

The growth of the web and Software as a Service (SaaS) revealed the importance of previously unknown economic constraints.
The same company carries both development and exploitation of an application at scale of unprecedented size.
To allow a continuous growth and sustainability of an application, it needs to address two contradictory goals : maintainability and performance efficiency.
These goals needs to be enforced by the platform supporting the application to build good development habits for the developers.
% In this chapter,
A platform designates any solution that allows to build an application on top of it, including programming languages, compilers, interpreters, frameworks, runtime libraries and so on.

\textit{75\% of your budget is dedicated to software maintenance.}\ftnt{http://www.castsoftware.com/glossary/software-maintainability}
The maintainability of an application relies on the modularity enforced by the platform used to build it.
Especially, higher order programming is crucial to build and compose modules efficiently.
% \footnote{Without higher-order programming, Object-Oriented Programming relied on numerous design patterns. Higher-order programming was finally adopted in OOP languages such as sJava 8 and C++11.}
It relies either on mutable states, or immutable states, but hardly on a combination of both.

However, neither mutable states nor immutable states allow performance efficiency.
Mutable states leads to synchronization overhead at coarser-grain level, while immutable states leads to communication overhead at finer-grain level.
Performance efficiency relies on a combination of shared mutable state at a fine-grain level, and immutable message passing at a coarse-grain level.
This combination breaks the modularity, hence the maintainability of an application.
A company has no choice but to commit huge development efforts to get efficient performances.

\illustration{virtuous circle between community and industry}
Moreover, a balance between these two contradictory goals is required for a platform to enter a virtuous circle of adoption.
The maintainability is required to be appealing to gather a community to support the ecosystem around the platform.
This community is appealing for the industry as a hiring pool.
The performance efficiency is required to be adopted by the industry to be economically viable.
And the industrial relevance provides the reason for this ecosystem to exist and the community to gather.

This chapter presents a broad view of the state of the art in the compromises between maintainability and performance efficiency.
It defines software maintainability, performance efficiency, and adoption in section \ref{chapter3:definitions} and all the underlying concepts, such as higher order programming and state mutability.
It then analyzes different platforms according to their focus. platforms focusing on maintainability are addressed in section \ref{chapter3:software-maintainability}, those focusing on performance efficiency in section \ref{chapter3:software-performance} and those focusing on a compromise between the two in section \ref{chapter3:software-abstraction}.

\input{03-state-of-the-art/Definitions}
\input{03-state-of-the-art/Software-maintainability}
\input{03-state-of-the-art/Software-performance}
\input{03-state-of-the-art/Software-abstraction}
\input{03-state-of-the-art/Analysis}

% GOTO chapter 4 - proposition
% \input{03-state-of-the-art/Objectives}



%-----------------------------------------------------------------------------%
                                    \endinput
%-----------------------------------------------------------------------------%


Some links I NEED to put :
--------------------------

https://glyph.twistedmatrix.com/2014/02/unyielding.html
http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/

Transitions :
  - Linkedin - http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin
  - Facebook - https://www.cs.princeton.edu/events/event/evolution-software-architecture-facebook / http://www.infoq.com/presentations/Evolution-of-Code-Design-at-Facebook
  - ... 

https://medium.com/@benorama/the-evolution-of-software-architecture-bd6ea674c477

https://en.wikipedia.org/wiki/Dataflow
https://en.wikipedia.org/wiki/Real-time_computing
https://en.wikipedia.org/wiki/Partitioned_global_address_space
https://en.wikipedia.org/wiki/SPMD

Albert Cohen
https://scholar.google.com/citations?user=MkKZKAMAAAAJ&hl=en

+ Paul Feautrier (Tutor of A. Cohen)


Similar problem :
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk
http://www.cs.indiana.edu/~lkuper/papers/lindsey-kuper-dissertation.pdf

PJS was abandoned :
https://groups.google.com/forum/#!topic/mozilla.dev.tech.js-engine/H-YEsejE6DA
https://bugzilla.mozilla.org/show_bug.cgi?id=1117724

See parallel JS for further work (maybe) :
http://smallcultfollowing.com/babysteps/blog/2014/04/24/parallel-pipelines-for-js/

Some chunks I might find useful later :
---------------------------------------

A good example of declarative sentence in everyday world : in case of fire, 
the elevators don't work -> you understand that you need to take the stairs.