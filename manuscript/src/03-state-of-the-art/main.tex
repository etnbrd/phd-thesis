\chapter{Software Design, State Of The Art} \label{chapter3}
\minitoc
\eject

\cit{A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.}{K. Sullivan, W. Griswold, Y. Cai, B. Hallen \cite{Sullivan2001}}

With the growth of Software as a Service (SaaS) on the web, the same company carries both development and exploitation of an application at scale of unprecedented size.
It revealed the importance of previously unknown economic constraints.
To assure the continuous growth and sustainability of an application, it needs to address two contradictory goals : development productivity and performance efficiency.
These goals needs to be enforced by the platform supporting the application to build good development habits for the developers.
A platform designates any solution that allows to build an application on top of it, including programming languages, compilers, interpreters, frameworks, runtime libraries and so on.

The productivity of a platform is the degree to which developers can quickly produce new and modify existing software.
It impacts the maintainability of the applications and relies on the modularity enforced by its platform.
\textit{75\% of your budget is dedicated to software maintenance.}\ftnt{http://www.castsoftware.com/glossary/software-maintainability}
Especially, higher order programming is crucial to build and compose modules productively.
It relies either on mutable states, or immutable states, but hardly on a combination of both.

However, neither mutable nor immutable states allows performance efficiency.
Mutable states leads to synchronization overhead at a coarser-grain level, while immutable states leads to communication overhead at a finer-grain level.
Efficiency relies on a combination of synchronization at a fine-grain level, and immutable message passing at a coarse-grain level.
This combination breaks the modularity, hence the productivity of an application.
A company has no choice but to commit huge development efforts to get efficient performances.

\illustration{virtuous circle between community and industry}
Moreover, a balance between productivity and efficiency is required for a platform to enter a virtuous circle of adoption.
The productivity is required to be appealing to gather a community to support the ecosystem around the platform.
This community is appealing for the industry as a hiring pool.
Additionally, the efficiency is required to be adopted by the industry to be economically viable.
And the industrial relevance provides the reason for this ecosystem to exist and the community to gather.

This chapter presents a broad view of the state of the art in the compromises between productivity and efficiency.
It defines software productivity, efficiency, and adoption in section \ref{chapter3:definitions} and all the underlying concepts, such as higher order programming and state mutability.
It then analyzes different platforms according to their focus. platforms focusing on productivity are addressed in section \ref{chapter3:software-productivity}, those focusing on efficiency in section \ref{chapter3:software-efficiency} and those focusing on a compromise between the two in section \ref{chapter3:software-adoption}.

\input{03-state-of-the-art/tables}

\input{03-state-of-the-art/Definitions}
\input{03-state-of-the-art/Software-productivity}
\input{03-state-of-the-art/Software-efficiency}
\input{03-state-of-the-art/Software-adoption}


\section{Discontinuous Developments}

This chapter presented a broad view of platforms and their balance between productivity and efficiency.
It established that the platforms favoring one eventually sacrifice the other.
Moreover, the adoption of these platforms proves that none of these compromises are sustainable.
Indeed, as presented in table \ref{tab:summary}, no platforms provides productivity, efficiency and adoption.

\TableSummary{tab:summary}

\separator

This chapter highlighted that productivity requires modularity through encapsulation and composition.
Productivity requires higher-order programming which relies on a global memory abstraction as explained in section \ref{chapter3:software-productivity:efficiency-limitations}.
Whereas efficiency requires a balance between fine-grain level shared state with synchronization and coarse-grain level independence with message-passing.
This discontinuity between fine-grain level and coarse-grain level avoids the global memory abstraction, hence productivity.
The absence of a global memory abstraction reserves efficient platforms for an elite of developers.
No platform can support simultaneously productivity and efficiency.
Nonetheless, a platforms needs to be adopted both by the industry and the community to be sustainable.

\nt{the arrow means require}
\begin{wrapfigure}{r}{0.38\textwidth}
  \vspace{-27pt}
  \begin{center}
    \includegraphics[width=0.35\textwidth]{../resources/insights.pdf}
  \end{center}
  \vspace{-20pt}
\end{wrapfigure}

The conclusion of this chapter is that no platform is able to follow a project from the early beginning until the industrial maturation of the project.
All the platforms tends to be stucked in a compromise between these two goals, and cannot follow the evolution required for this compromise.
These compromises are rigidly defined, while the need of the applicaiton is constantly evolving.
They lack the possibility to follow the organic evolution of a project.
Therefore, a project needs to change platform to change its priority, which leads to economical consequences.

To avoid these consequences, platforms would need to support productivity to allow the community to experiment, and organically start projects.
And then continuously shift toward efficiency as the project evolves, and requires it.

%-----------------------------------------------------------------------------%
                                    \endinput
%-----------------------------------------------------------------------------%


Some links I NEED to put :
--------------------------

https://glyph.twistedmatrix.com/2014/02/unyielding.html
http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/

Transitions :
  - Linkedin - http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin
  - Facebook - https://www.cs.princeton.edu/events/event/evolution-software-architecture-facebook / http://www.infoq.com/presentations/Evolution-of-Code-Design-at-Facebook
  - ... 

https://medium.com/@benorama/the-evolution-of-software-architecture-bd6ea674c477

https://en.wikipedia.org/wiki/Dataflow
https://en.wikipedia.org/wiki/Real-time_computing
https://en.wikipedia.org/wiki/Partitioned_global_address_space
https://en.wikipedia.org/wiki/SPMD

Albert Cohen
https://scholar.google.com/citations?user=MkKZKAMAAAAJ&hl=en

+ Paul Feautrier (Tutor of A. Cohen)


Similar problem :
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk
http://www.cs.indiana.edu/~lkuper/papers/lindsey-kuper-dissertation.pdf

PJS was abandoned :
https://groups.google.com/forum/#!topic/mozilla.dev.tech.js-engine/H-YEsejE6DA
https://bugzilla.mozilla.org/show_bug.cgi?id=1117724

See parallel JS for further work (maybe) :
http://smallcultfollowing.com/babysteps/blog/2014/04/24/parallel-pipelines-for-js/

Some chunks I might find useful later :
---------------------------------------

A good example of declarative sentence in everyday world : in case of fire, 
the elevators don't work -> you understand that you need to take the stairs.