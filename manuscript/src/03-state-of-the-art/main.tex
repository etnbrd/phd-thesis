\chapter{Software Design, State Of The Art} \label{chapter3}
\minitoc
\eject

\cit{A designer is responsible for producing the greatest benefit for any given investment of time, talent, money, and other resources.}{K. Sullivan, W. Griswold, Y. Cai, B. Hallen \cite{Sullivan2001a}}

\nt{TODO the next paragraph expresses well the idea, but is not clear enough yet}
The growth of the web and Software as a Service (SaaS) revealed the importance of previously unknown economic constraints.
The same company carries both development and exploitation of a service in scale of unprecedented size.
Development costs are reduced by following best practice, and by building maintainable softwares.
However, as seen in the previous chapter, it is compensated by increasing hardware performance, which eventually rises exploitation costs.
Similarly, exploitation costs are reduced by following more efficient programming models.
But again, it rises development costs.
So a SaaS company needs to cleverly allocate its budget between development and exploitation so as to limit the overall cost.

Eventually, a company faces the problem of scalability limitations.Compensating development with hardware becomes unsustainable.
The company has no choice but to commit huge development efforts to get correct performances.
This chapter draws a broad view of the relation between the orientation of development toward maintainability or scalable performance, and its consequences.

The best practices in software design advocate to decompose a problem into many subproblems.
The decomposition of the implementation of a problem improves directly its maintainability, development scalability and evolution.
This chapter present some of these best practices, \textit{e.g.} modular programming, structured design \cite{Stevens1974}, hierarchical structure \cite{Dijkstra1968} and object-oriented programming.

A few decades ago, the best practices were not concerned with execution performance.
Moore's law \cite{Moore1965} was wrongly interpreted as the assurance that hardware could always increase execution speed.
But eventually, the clock speed of processors plateaued \ftnt{https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/}\cite{Bohr2007}, and the processing units were organized as several execution units to continue improving performances.
But this hardware improvement could not anymore increase the execution speed without any additional development effort.

The best practices of software design then inherited two goals : to assure a scalable implementation evolution by decomposing it into subproblems, as well as assure a scalable parallel execution by decomposing the execution onto the several execution units.
As D. L. Parnas showed in 1972 \cite{Parnas1972}, it seems challenging to develop a software following a decomposition that satisfies both goals.

\begin{center}
\includegraphics[width=0.6\textwidth]{../ressources/state-of-the-art.pdf}
\end{center}

The evolution of economic constraints often force an SaaS company to switch from scalable development to scalable performance.
This switch implies huge development efforts.
There has been many attempts at reconciling the two goals to reduce these costs.
But none seems really convincing enough to be widely adopted.

The schema above is a graphical representation of the organization of this chapter, and more generally of the state of the art of software design.
The focus on development scalability, noted by number 1, are addressed in section \ref{chapter3:software-maintainability} while the focus on performance scalability, noted by number 3, are addressed in section \ref{chapter3:software-performance}.
Each of these direction of development contains works trying to meet the requirements from the opposing category, noted by number 2 and 4.
And finally, section \ref{chapter3:objectives} presents the objectives for this thesis, noted by number 5.

\input{03-state-of-the-art/Software-maintainability}
\input{03-state-of-the-art/Software-performance}
\input{03-state-of-the-art/Objectives}



%-----------------------------------------------------------------------------%
                                    \endinput
%-----------------------------------------------------------------------------%


Some links I NEED to put :
--------------------------

https://glyph.twistedmatrix.com/2014/02/unyielding.html
http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/

Transitions :
  - Linkedin - http://engineering.linkedin.com/architecture/brief-history-scaling-linkedin
  - Facebook - https://www.cs.princeton.edu/events/event/evolution-software-architecture-facebook / http://www.infoq.com/presentations/Evolution-of-Code-Design-at-Facebook
  - ... 

https://medium.com/@benorama/the-evolution-of-software-architecture-bd6ea674c477

https://en.wikipedia.org/wiki/Dataflow
https://en.wikipedia.org/wiki/Real-time_computing
https://en.wikipedia.org/wiki/Partitioned_global_address_space
https://en.wikipedia.org/wiki/SPMD

Albert Cohen
https://scholar.google.com/citations?user=MkKZKAMAAAAJ&hl=en

+ Paul Feautrier (Tutor of A. Cohen)


SPMD Single program multiple data
Partitioned global address space


Similar problem :
http://2015.splashcon.org/event/splash2015-splash-i-lindsey-kuper-talk
http://www.cs.indiana.edu/~lkuper/papers/lindsey-kuper-dissertation.pdf

PJS was abandoned :
https://groups.google.com/forum/#!topic/mozilla.dev.tech.js-engine/H-YEsejE6DA
https://bugzilla.mozilla.org/show_bug.cgi?id=1117724

See parallel JS for further work (maybe) :
http://smallcultfollowing.com/babysteps/blog/2014/04/24/parallel-pipelines-for-js/

Some chunks I might find useful later :
---------------------------------------

\cit{No matter how great the talent or efforts, some things just take time. You can't produce a baby in one month by getting nine women pregnant.}
{Warren Buffett}

A good example of declarative sentence in everyday world : in case of fire, 
the elevators don't work -> you understand that you need to take the stairs.