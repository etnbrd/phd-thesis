\section{Reconciliations}

TODO

\endinput

There are attempts at conciling the two approaches.

Without a transformation process :
Erlang - Jay Nelson, Structured Programming Using Processes

With a transformation process :
Parnas already advocated conciling the two methods in its Information Hiding paper.
Using an assembler to transform the high-level, development, vision into the low-level, execution, vision.





In its paper Simultaneous considered harmful, Reed finally present that the concept of mutex is inherently problematic in a distributed system.
And much much more.




\subsection{Design patterns}

\subsubsection{Algorithmic Skeletons}
\cite{McCool2010} Mc Cool, Structured Parallel Programmin with Deterministic Patterns

\textit{The general idea is that specific combinations of computation and data access recur in many different algorithms.}

\subsubsection{Accelerators}
CUDA, OpenCL

\subsubsection{SOA}

\subsubsection{Lock-free Algorithm}

  Lock-free algorithm are highly concurrent, as they can be replicated, however, they are limited, and really hard to develop.
  \url{https://en.wikipedia.org/wiki/Non-blocking_algorithm}


Microservices are in the reconciliation category, I think.
It is an attempt at reconciling the two organization. 
They advocate that software developers can manage the two organizations at a sufficiently fine level.
However, it doesn't support growth as well as sequential programming.